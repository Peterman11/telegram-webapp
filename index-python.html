<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–ê—Ä–±–∏—Ç—Ä–∞–∂ –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        :root {
            --bg-color: var(--tg-theme-bg-color, #ffffff);
            --text-color: var(--tg-theme-text-color, #000000);
            --hint-color: var(--tg-theme-hint-color, #999999);
            --button-color: var(--tg-theme-button-color, #3390ec);
            --button-text-color: var(--tg-theme-button-text-color, #ffffff);
            --secondary-bg: var(--tg-theme-secondary-bg-color, #f0f0f0);
            --positive-color: #4caf50;
            --negative-color: #ff4444;
            --warning-color: #ff9800;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-color);
            color: var(--text-color);
            padding: 16px;
            min-height: 100vh;
            margin: 0;
        }
        .container { max-width: 600px; margin: 0 auto; }
        h1 { font-size: 22px; margin-bottom: 16px; text-align: center; }
        .status-bar {
            text-align: center;
            padding: 10px 16px;
            margin-bottom: 12px;
            border-radius: 10px;
            font-size: 13px;
            font-weight: 500;
        }
        .status-bar.connected { background: var(--positive-color); color: white; }
        .status-bar.connecting { background: var(--warning-color); color: white; }
        .status-bar.disconnected { background: var(--negative-color); color: white; }
        .loading {
            text-align: center;
            padding: 40px 20px;
            color: var(--hint-color);
            font-size: 14px;
            line-height: 1.6;
        }
        .arbitrage-list { display: flex; flex-direction: column; gap: 12px; }
        .arbitrage-card {
            background: var(--secondary-bg);
            border-radius: 12px;
            padding: 14px 16px;
            border-left: 4px solid var(--button-color);
        }
        .arbitrage-card.positive { border-left-color: var(--positive-color); }
        .arbitrage-card.negative { border-left-color: var(--negative-color); }
        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        .coin-symbol { font-size: 17px; font-weight: 600; }
        .profit-badge {
            font-size: 16px;
            font-weight: 700;
            padding: 6px 12px;
            border-radius: 8px;
            color: white;
        }
        .profit-badge.positive { background: var(--positive-color); }
        .profit-badge.negative { background: var(--negative-color); }
        .exchanges-grid { display: flex; flex-direction: column; gap: 6px; font-size: 13px; }
        .exchange-row { display: flex; justify-content: space-between; align-items: center; }
        .exchange-name { color: var(--hint-color); }
        .exchange-prices { font-weight: 500; }
        .scenario {
            margin-top: 10px;
            padding: 10px 12px;
            background: linear-gradient(135deg, rgba(76, 175, 80, 0.15), rgba(76, 175, 80, 0.05));
            border-radius: 8px;
            border-left: 3px solid var(--positive-color);
            font-size: 14px;
            font-weight: 600;
            color: var(--positive-color);
        }
        .scenario.negative-scenario {
            background: linear-gradient(135deg, rgba(255, 68, 68, 0.15), rgba(255, 68, 68, 0.05));
            border-left-color: var(--negative-color);
            color: var(--negative-color);
        }
        .summary {
            text-align: center;
            padding: 10px;
            margin-bottom: 12px;
            font-size: 14px;
            font-weight: 500;
            color: var(--hint-color);
        }
        .refresh-btn {
            width: 100%;
            padding: 12px;
            margin-bottom: 12px;
            border: none;
            border-radius: 10px;
            background: var(--button-color);
            color: var(--button-text-color);
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
        }
        .recommendation {
            margin-top: 12px;
            padding: 12px;
            background: rgba(128, 128, 128, 0.1);
            border-radius: 8px;
        }
        .recommendation-title { font-size: 13px; font-weight: 600; margin-bottom: 10px; }
        .efficiency { display: flex; align-items: center; gap: 8px; margin-bottom: 8px; }
        .efficiency-value { font-size: 16px; font-weight: 700; }
        .efficiency-value.positive { color: var(--positive-color); }
        .efficiency-value.negative { color: var(--negative-color); }
        .efficiency-label { font-size: 12px; color: var(--hint-color); }
        .recommendation-grid { display: flex; flex-direction: column; gap: 6px; }
        .rec-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 8px;
            background: rgba(128, 128, 128, 0.1);
            border-radius: 6px;
            font-size: 12px;
        }
        .rec-amount { font-weight: 500; }
        .rec-profit.positive { color: var(--positive-color); }
        .rec-profit.negative { color: var(--negative-color); }
        .optimal-badge { margin-left: 6px; font-size: 10px; color: var(--positive-color); }
    </style>
</head>
<body>
    <div class="container">
        <h1>üìà –ê—Ä–±–∏—Ç—Ä–∞–∂ –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç</h1>
        <div id="statusBar" class="status-bar disconnected">‚è≥ –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ Python —Å–µ—Ä–≤–∏—Å—É...</div>
        <button id="refreshBtn" class="refresh-btn">üîÑ –û–±–Ω–æ–≤–∏—Ç—å –¥–∞–Ω–Ω—ã–µ</button>
        <div id="content" class="arbitrage-list">
            <div class="loading">‚è≥ –ó–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö...</div>
        </div>
    </div>

    <script>
        'use strict';
        
        const urlParams = new URLSearchParams(window.location.search);
        const pythonUrl = urlParams.get('python_url') || 'https://cryptobot-python-service-production.up.railway.app';
        const API_URL = pythonUrl;
        const UPDATE_INTERVAL = 3000;
        const AMOUNTS = [100, 250, 500, 1000, 2500, 5000];
        
        const FEES = {
            okx: 0.001,
            kucoin: 0.001,
            bitget: 0.001,
            huobi: 0.002,
            bitfinex: 0.002,
            bingx: 0.001,
            gateio: 0.002,
            bitstamp: 0.005,
            gemini: 0.004,
        };

        const EXCHANGE_NAMES = {
            okx: 'OKX',
            kucoin: 'KuCoin',
            bitget: 'Bitget',
            huobi: 'Huobi',
            bitfinex: 'Bitfinex',
            bingx: 'BingX',
            gateio: 'Gate.io',
            bitstamp: 'Bitstamp',
            gemini: 'Gemini',
        };

        const contentDiv = document.getElementById('content');
        const statusBar = document.getElementById('statusBar');
        const refreshBtn = document.getElementById('refreshBtn');
        
        let updateTimer = null;
        let isConnected = false;

        const tg = window.Telegram?.WebApp;
        if (tg) { tg.ready(); tg.expand(); }

        function formatPrice(num) {
            if (!Number.isFinite(num)) return 'N/A';
            return num.toFixed(2);
        }

        function calculateProfit(buyPrice, buyFee, sellPrice, sellFee, amount) {
            if (!buyPrice || !sellPrice || buyPrice <= 0 || sellPrice <= 0) return -Infinity;
            const afterBuyFee = amount * (1 - buyFee);
            const crypto = afterBuyFee / buyPrice;
            const gross = crypto * sellPrice;
            const net = gross * (1 - sellFee);
            return net - amount;
        }

        function calculateEfficiency(buyPrice, buyFee, sellPrice, sellFee) {
            const ratio = (sellPrice / buyPrice) * (1 - buyFee) * (1 - sellFee);
            return (ratio - 1) * 100;
        }

        function estimateLiquidity(coin, price) {
            const high = ['BTCUSDT', 'ETHUSDT', 'BNBUSDT', 'XRPUSDT', 'SOLUSDT'];
            const medium = ['ADAUSDT', 'DOTUSDT', 'AVAXUSDT', 'LINKUSDT', 'UNIUSDT', 'ATOMUSDT'];
            if (high.includes(coin)) return price > 1000 ? 50000 : 25000;
            if (medium.includes(coin)) return price > 10 ? 20000 : 10000;
            return price > 1 ? 5000 : 2000;
        }

        function calculateWeightedPrice(basePrice, amount, liquidity, isBuy) {
            if (amount < liquidity * 0.1) return basePrice;
            const utilization = Math.min(amount / liquidity, 1);
            const slippage = utilization * utilization * 0.005;
            return isBuy ? basePrice * (1 + slippage) : basePrice * (1 - slippage);
        }

        function calculateOptimalEntryAmount(coin, buyPrice, sellPrice, buyFee, sellFee, maxSlippage = 0.1) {
            const liquidity = estimateLiquidity(coin, buyPrice);
            const efficiency = calculateEfficiency(buyPrice, buyFee, sellPrice, sellFee);
            if (efficiency <= 0) return { optimalAmount: 0, maxProfit: 0, liquidity, reason: '–ê—Ä–±–∏—Ç—Ä–∞–∂ —É–±—ã—Ç–æ—á–µ–Ω' };
            let optimalAmount = 0, maxProfit = -Infinity;
            const testAmounts = [100, 250, 500, 1000, 2500, 5000, 10000];
            for (const amount of testAmounts) {
                if (amount > liquidity * 2) break;
                const actualBuy = calculateWeightedPrice(buyPrice, amount, liquidity, true);
                const actualSell = calculateWeightedPrice(sellPrice, amount, liquidity, false);
                const totalSlippage = ((actualBuy - buyPrice) / buyPrice + (sellPrice - actualSell) / sellPrice) * 100;
                if (totalSlippage > maxSlippage) break;
                const profit = calculateProfit(actualBuy, buyFee, actualSell, sellFee, amount);
                if (profit > maxProfit) { maxProfit = profit; optimalAmount = amount; }
            }
            return { optimalAmount, maxProfit: maxProfit === -Infinity ? 0 : maxProfit, liquidity, reason: optimalAmount > 0 ? '–û–ø—Ç–∏–º–∞–ª—å–Ω–∞—è —Å—É–º–º–∞ –Ω–∞–π–¥–µ–Ω–∞' : '–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–∞—è –ª–∏–∫–≤–∏–¥–Ω–æ—Å—Ç—å' };
        }

        function calculateRecommendations(coin, buyPrice, buyFee, sellPrice, sellFee) {
            const efficiency = calculateEfficiency(buyPrice, buyFee, sellPrice, sellFee);
            const isProfitable = efficiency > 0;
            const optimalEntry = calculateOptimalEntryAmount(coin, buyPrice, sellPrice, buyFee, sellFee);
            const recommendations = AMOUNTS.map(amount => {
                const liquidity = estimateLiquidity(coin, buyPrice);
                const actualBuy = calculateWeightedPrice(buyPrice, amount, liquidity, true);
                const actualSell = calculateWeightedPrice(sellPrice, amount, liquidity, false);
                const profit = calculateProfit(actualBuy, buyFee, actualSell, sellFee, amount);
                const slippage = ((actualBuy - buyPrice) / buyPrice + (sellPrice - actualSell) / sellPrice) * 100;
                return { amount, profit, roi: efficiency, slippage, actualBuyPrice: actualBuy, actualSellPrice: actualSell };
            });
            return {
                efficiency,
                isProfitable,
                optimalAmount: optimalEntry.optimalAmount || (isProfitable ? 500 : 0),
                maxProfit: optimalEntry.maxProfit,
                liquidity: optimalEntry.liquidity,
                recommendations
            };
        }

        function updateStatus(connected, connectedCount = 0, totalCount = 0) {
            isConnected = connected;
            
            if (connected) {
                statusBar.className = 'status-bar connected';
                statusBar.textContent = `‚úÖ Python —Å–µ—Ä–≤–∏—Å –ø–æ–¥–∫–ª—é—á–µ–Ω | ${connectedCount}/${totalCount} –±–∏—Ä–∂`;
            } else {
                statusBar.className = 'status-bar disconnected';
                statusBar.textContent = '‚ùå –ù–µ—Ç –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ Python —Å–µ—Ä–≤–∏—Å—É';
            }
        }

        async function fetchPrices() {
            try {
                const response = await fetch(`${API_URL}/api/webapp/prices`);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const result = await response.json();
                
                if (result.success && result.data) {
                    const totalPrices = Object.values(result.data).reduce((sum, ex) => sum + Object.keys(ex).length, 0);
                    const exchangeCount = new Set();
                    Object.values(result.data).forEach(exchanges => {
                        Object.keys(exchanges).forEach(ex => exchangeCount.add(ex));
                    });
                    
                    updateStatus(true, exchangeCount.size, Object.keys(FEES).length);
                    renderArbitrage(result.data);
                } else {
                    throw new Error(result.error || 'No data');
                }
                
            } catch (error) {
                console.error('Fetch error:', error);
                updateStatus(false);
                contentDiv.innerHTML = `
                    <div class="loading">
                        ‚ùå –û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ Python —Å–µ—Ä–≤–∏—Å—É<br><br>
                        –°–µ—Ä–≤–∏—Å –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –¥–æ—Å—Ç—É–ø–µ–Ω –Ω–∞ Railway:<br>
                        <code>${API_URL}</code>
                    </div>
                `;
            }
        }

        function renderArbitrage(data) {
            const results = [];
            const skipped = [];
            const exchangeIds = Object.keys(FEES);
            
            for (const [coin, exchanges] of Object.entries(data)) {
                const allExchangeData = exchangeIds.map(id => {
                    const exData = exchanges[id];
                    return {
                        id,
                        name: EXCHANGE_NAMES[id],
                        fee: FEES[id],
                        data: exData && exData.bid && exData.ask ? { bid: exData.bid, ask: exData.ask } : null,
                        hasData: exData && exData.bid > 0 && exData.ask > 0
                    };
                });
                
                const exchangeData = allExchangeData.filter(e => e.hasData);
                
                if (exchangeData.length < 2) {
                    skipped.push(coin);
                    continue;
                }
                
                let best = { profit: -Infinity, scenario: null, buyEx: null, sellEx: null };
                
                for (const buyEx of exchangeData) {
                    for (const sellEx of exchangeData) {
                        if (buyEx.id === sellEx.id) continue;
                        
                        const profit = calculateProfit(
                            buyEx.data.ask, buyEx.fee,
                            sellEx.data.bid, sellEx.fee,
                            100
                        );
                        
                        if (profit > best.profit) {
                            best = {
                                profit,
                                scenario: {
                                    buyExchange: buyEx.name,
                                    sellExchange: sellEx.name,
                                },
                                buyEx,
                                sellEx
                            };
                        }
                    }
                }
                
                if (best.scenario) {
                    const recs = calculateRecommendations(
                        coin,
                        best.buyEx.data.ask, best.buyEx.fee,
                        best.sellEx.data.bid, best.sellEx.fee
                    );
                    results.push({
                        coin,
                        profit: best.profit,
                        scenario: best.scenario,
                        exchanges: allExchangeData,
                        buyPrice: best.buyEx.data.ask,
                        sellPrice: best.sellEx.data.bid,
                        buyEx: best.buyEx,
                        sellEx: best.sellEx,
                        recommendations: recs,
                    });
                }
            }
            
            results.sort((a, b) => b.profit - a.profit);
            
            const profitableResults = results.filter(r => r.profit >= 0);
            const topResults = profitableResults.length > 0 
                ? profitableResults.slice(0, 100)
                : results.slice(0, 50);
            
            if (topResults.length === 0) {
                contentDiv.innerHTML = `
                    <div class="loading">
                        ‚è≥ –û–∂–∏–¥–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö...<br><br>
                        Python —Å–µ—Ä–≤–∏—Å —Å–æ–±–∏—Ä–∞–µ—Ç —Ü–µ–Ω—ã —Å–æ –≤—Å–µ—Ö –±–∏—Ä–∂
                    </div>
                `;
                return;
            }
            
            const positiveCount = topResults.filter(r => r.profit >= 0).length;
            const totalCoins = Object.keys(data).length;
            const shownCoins = topResults.length;
            const skippedCount = skipped.length;
            
            let summaryText = `üèÜ –ü–æ–∫–∞–∑–∞–Ω–æ ${shownCoins} –∏–∑ ${totalCoins} –º–æ–Ω–µ—Ç`;
            if (positiveCount > 0) {
                summaryText += ` | ${positiveCount} —Å –ø—Ä–∏–±—ã–ª—å—é`;
            }
            if (skippedCount > 0) {
                summaryText += ` | ${skippedCount} –ø—Ä–æ–ø—É—â–µ–Ω–æ (–Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö)`;
            }
            
            let html = `
                <div class="summary">${summaryText}</div>
                <div class="arbitrage-list">
            `;
            
            for (const result of topResults) {
                const isPositive = result.profit >= 0;
                const profitText = isPositive ? `+${formatPrice(result.profit)}` : formatPrice(result.profit);
                
                let exchangesHtml = '';
                for (const ex of result.exchanges) {
                    if (ex.hasData) {
                        const isBest = (ex.id === result.buyEx.id || ex.id === result.sellEx.id);
                        const style = isBest ? 'font-weight: 700;' : '';
                        exchangesHtml += `
                            <div class="exchange-row">
                                <span class="exchange-name" style="${style}">${ex.name}:</span>
                                <span class="exchange-prices" style="${style}">
                                    –ü–æ–∫—É–ø–∫–∞ ${formatPrice(ex.data.ask)} | –ü—Ä–æ–¥–∞–∂–∞ ${formatPrice(ex.data.bid)}
                                </span>
                            </div>
                        `;
                    } else {
                        exchangesHtml += `
                            <div class="exchange-row" style="opacity: 0.5;">
                                <span class="exchange-name">${ex.name}:</span>
                                <span class="exchange-prices" style="color: var(--hint-color); font-style: italic;">
                                    ‚è≥ –û–∂–∏–¥–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö...
                                </span>
                            </div>
                        `;
                    }
                }
                
                html += `
                    <div class="arbitrage-card ${isPositive ? 'positive' : 'negative'}">
                        <div class="card-header">
                            <span class="coin-symbol">${result.coin.replace('USDT', '/USDT')}</span>
                            <span class="profit-badge ${isPositive ? 'positive' : 'negative'}">${profitText} USDT</span>
                        </div>
                        <div class="exchanges-grid">${exchangesHtml}</div>
                        <div class="scenario ${isPositive ? '' : 'negative-scenario'}">
                            ${isPositive ? 'üöÄ' : 'üí°'} <strong>${result.scenario.buyExchange}</strong> ‚Üí <strong>${result.scenario.sellExchange}</strong>
                        </div>
                        
                        <div style="margin-top: 10px; padding: 10px; background: rgba(128, 128, 128, 0.05); border-radius: 8px; font-size: 12px; color: var(--hint-color);">
                            <div style="margin-bottom: 4px;"><strong>üìã –î–µ—Ç–∞–ª–∏ —Ä–∞—Å—á–µ—Ç–∞ (–Ω–∞ 100 USDT):</strong></div>
                            <div style="margin-bottom: 2px;">üõí –ü–æ–∫—É–ø–∫–∞ –Ω–∞ ${result.scenario.buyExchange}: ${formatPrice(result.buyPrice)} USDT</div>
                            <div style="margin-bottom: 2px;">üí∏ –ü—Ä–æ–¥–∞–∂–∞ –Ω–∞ ${result.scenario.sellExchange}: ${formatPrice(result.sellPrice)} USDT</div>
                            <div style="margin-bottom: 2px;">üí≥ –ö–æ–º–∏—Å—Å–∏–∏: ${(result.buyEx.fee * 100).toFixed(2)}% + ${(result.sellEx.fee * 100).toFixed(2)}%</div>
                            <div style="color: ${isPositive ? 'var(--positive-color)' : 'var(--negative-color)'}; font-weight: 600;">üí∞ –ß–∏—Å—Ç–∞—è –ø—Ä–∏–±—ã–ª—å: ${profitText} USDT</div>
                        </div>
                        
                        <div class="recommendation">
                            <div class="recommendation-title">üìä –û–ø—Ç–∏–º–∞–ª—å–Ω–∞—è —Å—É–º–º–∞ –≤—Ö–æ–¥–∞ (—Å —É—á–µ—Ç–æ–º –ª–∏–∫–≤–∏–¥–Ω–æ—Å—Ç–∏)</div>
                            <div class="efficiency">
                                <div class="efficiency-value ${result.recommendations.efficiency >= 0 ? 'positive' : 'negative'}">${result.recommendations.efficiency >= 0 ? '+' : ''}${result.recommendations.efficiency.toFixed(3)}%</div>
                                <div class="efficiency-label">–≠—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—å (ROI)</div>
                            </div>
                            ${result.recommendations.isProfitable && result.recommendations.optimalAmount > 0 ? `
                                <div style="margin-top: 10px; padding: 10px; background: rgba(76, 175, 80, 0.1); border-radius: 8px;">
                                    <div style="font-size: 14px; font-weight: 600; color: var(--positive-color); margin-bottom: 6px;">‚≠ê –†–µ–∫–æ–º–µ–Ω–¥—É–µ–º–∞—è —Å—É–º–º–∞: <strong>${result.recommendations.optimalAmount} USDT</strong></div>
                                    <div style="font-size: 12px; color: var(--hint-color);">üí∞ –ü—Ä–∏–±—ã–ª—å: ~${formatPrice(result.recommendations.maxProfit || 0)} USDT ¬∑ –õ–∏–∫–≤–∏–¥–Ω–æ—Å—Ç—å –¥–æ ${Math.round(result.recommendations.liquidity / 1000)}k USDT</div>
                                </div>
                            ` : ''}
                            <div class="recommendation-grid" style="margin-top: 10px;">
                                ${[100, 500, 1000, 2500].map(amount => {
                                    const rec = result.recommendations.recommendations.find(r => r.amount === amount);
                                    if (!rec) return '';
                                    const isOptimal = amount === result.recommendations.optimalAmount;
                                    const profitClass = rec.profit >= 0 ? 'positive' : 'negative';
                                    const profitSign = rec.profit >= 0 ? '+' : '';
                                    const slippageText = rec.slippage > 0.01 ? ` (–ø—Ä–æ—Å–µ–¥–∞–Ω–∏–µ: ${rec.slippage.toFixed(3)}%)` : '';
                                    return `<div class="rec-item"><span class="rec-amount">${amount} USDT${isOptimal ? '<span class="optimal-badge">‚≠ê –û–ø—Ç–∏–º–∞–ª—å–Ω–æ</span>' : ''}</span><span class="rec-profit ${profitClass}">${profitSign}${formatPrice(rec.profit)} USDT${slippageText}</span></div>`;
                                }).join('')}
                            </div>
                            ${result.recommendations.isProfitable ? '<div style="margin-top: 10px; font-size: 11px; color: var(--hint-color);">üí° –°—É–º–º—ã —Å —É—á–µ—Ç–æ–º –ø—Ä–æ—Å–µ–¥–∞–Ω–∏—è –ø—Ä–∏ –ø–æ–∫—É–ø–∫–µ/–ø—Ä–æ–¥–∞–∂–µ</div>' : '<div style="margin-top: 10px; font-size: 12px; color: var(--negative-color);">‚ö†Ô∏è –ê—Ä–±–∏—Ç—Ä–∞–∂ —É–±—ã—Ç–æ—á–Ω—ã–π –ø—Ä–∏ –ª—é–±–æ–π —Å—É–º–º–µ</div>'}
                        </div>
                    </div>
                `;
            }
            
            html += '</div>';
            contentDiv.innerHTML = html;
        }

        refreshBtn.onclick = () => {
            console.log('üîÑ –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö...');
            fetchPrices();
        };

        function startAutoUpdate() {
            if (updateTimer) clearInterval(updateTimer);
            updateTimer = setInterval(fetchPrices, UPDATE_INTERVAL);
        }

        console.log('üöÄ Web App –∑–∞–ø—É—â–µ–Ω (Python CCXT —Ä–µ–∂–∏–º)');
        fetchPrices();
        startAutoUpdate();
    </script>
</body>
</html>
