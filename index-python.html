<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>–ê—Ä–±–∏—Ç—Ä–∞–∂ –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç v2.0</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        :root {
            --bg-color: #0a0e17;
            --bg-card: rgba(18, 25, 42, 0.85);
            --text-color: #e8ecf4;
            --hint-color: #8b9dc3;
            --button-color: #3b82f6;
            --button-text-color: #ffffff;
            --border-gradient: linear-gradient(135deg, rgba(59, 130, 246, 0.4), rgba(139, 92, 246, 0.2));
            --positive-color: #22c55e;
            --negative-color: #ef4444;
            --warning-color: #f59e0b;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(160deg, #0a0e17 0%, #0f172a 35%, #1e1b4b 70%, #0f172a 100%);
            color: var(--text-color);
            padding: 16px;
            min-height: 100vh;
            margin: 0;
            position: relative;
            overflow-x: hidden;
        }
        body::before {
            content: '';
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: 
                radial-gradient(ellipse 100% 80% at 50% -30%, rgba(59, 130, 246, 0.35), transparent 50%),
                radial-gradient(ellipse 80% 60% at 90% 20%, rgba(139, 92, 246, 0.25), transparent 45%),
                radial-gradient(ellipse 70% 50% at 10% 60%, rgba(99, 102, 241, 0.2), transparent 45%),
                radial-gradient(circle at 50% 100%, rgba(34, 197, 94, 0.08), transparent 40%);
            pointer-events: none;
            z-index: 0;
        }
        .container { max-width: 600px; margin: 0 auto; position: relative; z-index: 1; }
        h1 {
            font-size: 22px;
            margin-bottom: 12px;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        h1 .title-icon { font-size: 24px; }
        .status-bar {
            text-align: center;
            padding: 10px 16px;
            margin-bottom: 12px;
            border-radius: 10px;
            font-size: 13px;
            font-weight: 500;
        }
        .status-bar.connected { background: var(--positive-color); color: white; }
        .status-bar.connecting { background: var(--warning-color); color: white; }
        .status-bar.disconnected { background: var(--negative-color); color: white; }
        .loading {
            text-align: center;
            padding: 40px 20px;
            color: var(--hint-color);
            font-size: 14px;
            line-height: 1.6;
        }
        .refresh-btn {
            width: 100%;
            padding: 12px;
            margin-bottom: 12px;
            border: none;
            border-radius: 10px;
            background: var(--button-color);
            color: var(--button-text-color);
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        .summary {
            text-align: center;
            padding: 10px;
            margin-bottom: 12px;
            font-size: 14px;
            font-weight: 500;
            color: var(--hint-color);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }
        .arbitrage-list { display: flex; flex-direction: column; gap: 14px; }
        .arbitrage-card {
            background: linear-gradient(145deg, rgba(18, 25, 42, 0.92), rgba(30, 27, 75, 0.6));
            backdrop-filter: blur(8px);
            border-radius: 16px;
            padding: 16px 18px;
            border: 1px solid transparent;
            background-clip: padding-box;
            box-shadow: 0 4px 24px rgba(0, 0, 0, 0.3), 0 0 0 1px rgba(255,255,255,0.04);
            position: relative;
        }
        .arbitrage-card::before {
            content: '';
            position: absolute;
            inset: 0;
            border-radius: 16px;
            padding: 2px;
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.6), rgba(139, 92, 246, 0.4), rgba(59, 130, 246, 0.3));
            -webkit-mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
            mask: linear-gradient(#fff 0 0) content-box, linear-gradient(#fff 0 0);
            -webkit-mask-composite: xor;
            mask-composite: exclude;
            pointer-events: none;
        }
        .arbitrage-card.positive { --accent: var(--positive-color); }
        .arbitrage-card.negative { --accent: var(--negative-color); }
        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }
        .card-header-left {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        .coin-icon-wrap {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            overflow: hidden;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
        }
        .coin-icon-wrap img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        .coin-symbol { font-size: 18px; font-weight: 600; }
        .profit-badge {
            font-size: 15px;
            font-weight: 700;
            padding: 6px 12px;
            border-radius: 10px;
            color: white;
        }
        .profit-badge.positive { background: var(--positive-color); }
        .profit-badge.negative { background: var(--negative-color); }
        .exchanges-grid { display: flex; flex-direction: column; gap: 6px; font-size: 13px; }
        .exchange-row { display: flex; justify-content: space-between; align-items: center; padding: 6px 10px; margin: 2px -10px; border-radius: 8px; }
        .exchange-row.best-buy {
            background: linear-gradient(90deg, rgba(34, 197, 94, 0.25), rgba(34, 197, 94, 0.08));
            border-left: 4px solid var(--positive-color);
            font-weight: 700;
        }
        .exchange-row.best-buy .exchange-name, .exchange-row.best-buy .exchange-prices { color: #4ade80; }
        .exchange-row.best-sell {
            background: linear-gradient(90deg, rgba(59, 130, 246, 0.25), rgba(59, 130, 246, 0.08));
            border-left: 4px solid #3b82f6;
            font-weight: 700;
        }
        .exchange-row.best-sell .exchange-name, .exchange-row.best-sell .exchange-prices { color: #60a5fa; }
        .best-label { font-size: 10px; text-transform: uppercase; letter-spacing: 0.5px; opacity: 0.95; }
        .exchange-name { color: var(--hint-color); }
        .exchange-prices { font-weight: 500; }
        .scenario {
            margin-top: 10px;
            padding: 10px 12px;
            background: linear-gradient(135deg, rgba(34, 197, 94, 0.12), rgba(34, 197, 94, 0.04));
            border-radius: 8px;
            border-left: 3px solid var(--positive-color);
            font-size: 14px;
            font-weight: 600;
            color: var(--positive-color);
        }
        .scenario.negative-scenario {
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.12), rgba(239, 68, 68, 0.04));
            border-left-color: var(--negative-color);
            color: var(--negative-color);
        }
        .detail-block {
            margin-top: 12px;
            padding: 12px;
            background: rgba(255, 255, 255, 0.04);
            border-radius: 10px;
            font-size: 12px;
            color: var(--hint-color);
        }
        .detail-block strong { color: var(--text-color); }
        .recommendation {
            margin-top: 12px;
            padding: 12px;
            background: rgba(255, 255, 255, 0.04);
            border-radius: 10px;
        }
        .recommendation-title { font-size: 13px; font-weight: 600; margin-bottom: 10px; }
        .efficiency { display: flex; align-items: center; gap: 8px; margin-bottom: 8px; }
        .efficiency-value { font-size: 16px; font-weight: 700; }
        .efficiency-value.positive { color: var(--positive-color); }
        .efficiency-value.negative { color: var(--negative-color); }
        .efficiency-label { font-size: 12px; color: var(--hint-color); }
        .recommendation-grid { display: flex; flex-direction: column; gap: 6px; }
        .rec-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 8px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            font-size: 12px;
        }
        .rec-amount { font-weight: 500; }
        .rec-profit.positive { color: var(--positive-color); }
        .rec-profit.negative { color: var(--negative-color); }
        .optimal-badge { margin-left: 6px; font-size: 10px; color: var(--positive-color); }
    </style>
</head>
<body>
    <div class="container">
        <h1><span class="title-icon">‚ö°</span> –ê—Ä–±–∏—Ç—Ä–∞–∂ –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç</h1>
        <div id="statusBar" class="status-bar disconnected">‚è≥ –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ Python —Å–µ—Ä–≤–∏—Å—É...</div>
        <button id="refreshBtn" class="refresh-btn"><span>üîÑ</span> –û–±–Ω–æ–≤–∏—Ç—å –¥–∞–Ω–Ω—ã–µ</button>
        <div id="content" class="arbitrage-list">
            <div class="loading">‚è≥ –ó–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö...</div>
        </div>
    </div>

    <script>
        'use strict';
        
        const urlParams = new URLSearchParams(window.location.search);
        const pythonUrl = urlParams.get('python_url') || 'https://cryptobot-python-service-production.up.railway.app';
        const API_URL = pythonUrl;
        const UPDATE_INTERVAL = 3000;
        const AMOUNTS = [100, 250, 500, 1000, 2500, 5000];
        
        const FEES = {
            okx: 0.001,
            kucoin: 0.001,
            bitget: 0.001,
            huobi: 0.002,
            bitfinex: 0.002,
            bingx: 0.001,
            gateio: 0.002,
            bitstamp: 0.005,
            gemini: 0.004,
            cryptocom: 0.001,
            bitmart: 0.0025,
            coinex: 0.002,
            digifinex: 0.002,
            ascendex: 0.001,
            bitrue: 0.00098,
            hitbtc: 0.0009,
            whitebit: 0.001,
            bitvavo: 0.0025,
            exmo: 0.002,
            cex: 0.0025,
            fmfwio: 0.002,
            lbank: 0.001,
            phemex: 0.001,
        };

        const EXCHANGE_NAMES = {
            okx: 'OKX',
            kucoin: 'KuCoin',
            bitget: 'Bitget',
            huobi: 'Huobi',
            bitfinex: 'Bitfinex',
            bingx: 'BingX',
            gateio: 'Gate.io',
            bitstamp: 'Bitstamp',
            gemini: 'Gemini',
            cryptocom: 'Crypto.com',
            bitmart: 'BitMart',
            coinex: 'CoinEx',
            digifinex: 'DigiFinex',
            ascendex: 'AscendEX',
            bitrue: 'Bitrue',
            hitbtc: 'HitBTC',
            whitebit: 'WhiteBIT',
            bitvavo: 'Bitvavo',
            exmo: 'EXMO',
            cex: 'CEX.IO',
            fmfwio: 'FMFW.io',
            lbank: 'LBank',
            phemex: 'Phemex',
        };

        // –¶–≤–µ—Ç –¥–ª—è –∫–∞–∂–¥–æ–π –º–æ–Ω–µ—Ç—ã (–±—Ä–µ–Ω–¥-—Ü–≤–µ—Ç–∞)
        const COIN_COLORS = {
            btc: '#f7931a', eth: '#627eea', bnb: '#f3ba2f', xrp: '#23292f', sol: '#14f195',
            trx: '#ef0027', doge: '#c3a634', ada: '#0033ad', bch: '#8dc351', xmr: '#ff6600',
            link: '#2a5ada', xlm: '#14b6e7', sui: '#6fbcf0', ltc: '#345d9d', avax: '#e84142',
            hbar: '#000000', shib: '#ffa409', ton: '#0098ea', dot: '#e6007a', uni: '#ff007a',
            tao: '#8b5cf6', aave: '#b6509e', pepe: '#3d9909', near: '#000000', icp: '#29abe2',
            etc: '#328332', ondo: '#9333ea', pol: '#8247e5', wld: '#000000', apt: '#000000',
            kas: '#49d9b3', atom: '#2e3148', algo: '#000000', render: '#000000', arb: '#2c374b',
            trump: '#ff0000', fil: '#0090ff', stx: '#5546ff', virtual: '#8b5cf6', chz: '#cd0124',
            fet: '#0714fd', crv: '#40649f', imx: '#000000', inj: '#00f2fe', bonk: '#ff9500',
            xdc: '#5092cc', sei: '#8b5cf6', cake: '#d1884f', jup: '#19fb9b', pengu: '#6366f1',
            xtz: '#2c7df7', nexo: '#1a4199', op: '#ff0420', zro: '#000000', kaia: '#8b5cf6',
            vet: '#15bdff', dash: '#008ce7', qnt: '#000000', flr: '#e84142', ip: '#8b5cf6',
            zeta: '#00bc8d', ena: '#8b5cf6', grt: '#6f4cff', theta: '#2ab8e6', rune: '#00ccff',
            sand: '#04adef', mana: '#ff2d55', gala: '#000000', ape: '#0059ff', axs: '#0055d5',
            flow: '#00ef8b', eos: '#000000', neo: '#58bf00', iota: '#000000', zil: '#49c1bf',
            egld: '#000000', snx: '#00d1ff', comp: '#00d395', yfi: '#006ae3', lrc: '#1c60ff',
            enj: '#7866d5', bat: '#ff5000', zec: '#ecb244', mkr: '#1aab9b', ldo: '#00a3ff',
            ftm: '#13b5ec', matic: '#8247e5', woo: '#000000', gmx: '#2d42fc', dydx: '#6966ff',
            blur: '#ff8700', pendle: '#27f2e1', tia: '#8b5cf6', pyth: '#695ecb', w: '#8b5cf6',
            jto: '#8b5cf6', ordi: '#ff9500', sats: '#8b5cf6', wif: '#8b5cf6',
        };

        const COIN_ICON_CDN = 'https://cdn.jsdelivr.net/npm/cryptocurrency-icons@0.18.1/128';
        const COIN_ICON_ALIAS = { '1000pepe': 'pepe', '1000pep': 'pepe', 'pol': 'matic', 'w': 'wbtc' };

        function getCoinIconUrl(coin) {
            const raw = (coin || '').replace(/\/USDT$/i, '').trim();
            const key = raw.toLowerCase();
            const symbol = COIN_ICON_ALIAS[key] || key;
            return `${COIN_ICON_CDN}/${symbol}.png`;
        }

        function getCoinFallbackIconUrl(coin) {
            const raw = (coin || '').replace(/\/USDT$/i, '').trim();
            const symbol = raw.toLowerCase();
            const letter = (raw.charAt(0) || '?').toUpperCase();
            const color = COIN_COLORS[symbol] || '#8b5cf6';
            const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="128" height="128" viewBox="0 0 128 128"><rect width="128" height="128" rx="64" fill="${color}"/><text x="64" y="90" font-family="Arial,sans-serif" font-size="72" font-weight="700" fill="white" text-anchor="middle">${letter}</text></svg>`;
            return 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(svg)));
        }

        function getCoinFallbackLetter(coin) {
            const raw = (coin || '').replace(/\/USDT$/i, '').trim();
            return (raw.charAt(0) || '?').toUpperCase();
        }

        const contentDiv = document.getElementById('content');
        const statusBar = document.getElementById('statusBar');
        const refreshBtn = document.getElementById('refreshBtn');
        
        let updateTimer = null;
        let isConnected = false;

        const tg = window.Telegram?.WebApp;
        if (tg) { tg.ready(); tg.expand(); }

        function formatPrice(num) {
            if (!Number.isFinite(num)) return 'N/A';
            return num.toFixed(2);
        }

        function calculateProfit(buyPrice, buyFee, sellPrice, sellFee, amount) {
            if (!buyPrice || !sellPrice || buyPrice <= 0 || sellPrice <= 0) return -Infinity;
            const afterBuyFee = amount * (1 - buyFee);
            const crypto = afterBuyFee / buyPrice;
            const gross = crypto * sellPrice;
            const net = gross * (1 - sellFee);
            return net - amount;
        }

        function calculateEfficiency(buyPrice, buyFee, sellPrice, sellFee) {
            const ratio = (sellPrice / buyPrice) * (1 - buyFee) * (1 - sellFee);
            return (ratio - 1) * 100;
        }

        function estimateLiquidity(coin, price) {
            const high = ['BTCUSDT', 'ETHUSDT', 'BNBUSDT', 'XRPUSDT', 'SOLUSDT'];
            const medium = ['ADAUSDT', 'DOTUSDT', 'AVAXUSDT', 'LINKUSDT', 'UNIUSDT', 'ATOMUSDT'];
            if (high.includes(coin)) return price > 1000 ? 50000 : 25000;
            if (medium.includes(coin)) return price > 10 ? 20000 : 10000;
            return price > 1 ? 5000 : 2000;
        }

        function calculateWeightedPrice(basePrice, amount, liquidity, isBuy) {
            if (amount < liquidity * 0.1) return basePrice;
            const utilization = Math.min(amount / liquidity, 1);
            const slippage = utilization * utilization * 0.005;
            return isBuy ? basePrice * (1 + slippage) : basePrice * (1 - slippage);
        }

        function calculateOptimalEntryAmount(coin, buyPrice, sellPrice, buyFee, sellFee, maxSlippage = 0.1) {
            const liquidity = estimateLiquidity(coin, buyPrice);
            const efficiency = calculateEfficiency(buyPrice, buyFee, sellPrice, sellFee);
            if (efficiency <= 0) return { optimalAmount: 0, maxProfit: 0, liquidity, reason: '–ê—Ä–±–∏—Ç—Ä–∞–∂ —É–±—ã—Ç–æ—á–µ–Ω' };
            let optimalAmount = 0, maxProfit = -Infinity;
            const testAmounts = [100, 250, 500, 1000, 2500, 5000, 10000];
            for (const amount of testAmounts) {
                if (amount > liquidity * 2) break;
                const actualBuy = calculateWeightedPrice(buyPrice, amount, liquidity, true);
                const actualSell = calculateWeightedPrice(sellPrice, amount, liquidity, false);
                const totalSlippage = ((actualBuy - buyPrice) / buyPrice + (sellPrice - actualSell) / sellPrice) * 100;
                if (totalSlippage > maxSlippage) break;
                const profit = calculateProfit(actualBuy, buyFee, actualSell, sellFee, amount);
                if (profit > maxProfit) { maxProfit = profit; optimalAmount = amount; }
            }
            return { optimalAmount, maxProfit: maxProfit === -Infinity ? 0 : maxProfit, liquidity, reason: optimalAmount > 0 ? '–û–ø—Ç–∏–º–∞–ª—å–Ω–∞—è —Å—É–º–º–∞ –Ω–∞–π–¥–µ–Ω–∞' : '–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–∞—è –ª–∏–∫–≤–∏–¥–Ω–æ—Å—Ç—å' };
        }

        function calculateRecommendations(coin, buyPrice, buyFee, sellPrice, sellFee) {
            const efficiency = calculateEfficiency(buyPrice, buyFee, sellPrice, sellFee);
            const isProfitable = efficiency > 0;
            const optimalEntry = calculateOptimalEntryAmount(coin, buyPrice, sellPrice, buyFee, sellFee);
            const recommendations = AMOUNTS.map(amount => {
                const liquidity = estimateLiquidity(coin, buyPrice);
                const actualBuy = calculateWeightedPrice(buyPrice, amount, liquidity, true);
                const actualSell = calculateWeightedPrice(sellPrice, amount, liquidity, false);
                const profit = calculateProfit(actualBuy, buyFee, actualSell, sellFee, amount);
                const slippage = ((actualBuy - buyPrice) / buyPrice + (sellPrice - actualSell) / sellPrice) * 100;
                return { amount, profit, roi: efficiency, slippage, actualBuyPrice: actualBuy, actualSellPrice: actualSell };
            });
            return {
                efficiency,
                isProfitable,
                optimalAmount: optimalEntry.optimalAmount || (isProfitable ? 500 : 0),
                maxProfit: optimalEntry.maxProfit,
                liquidity: optimalEntry.liquidity,
                recommendations
            };
        }

        function updateStatus(connected, connectedCount = 0, totalCount = 0) {
            isConnected = connected;
            
            if (connected) {
                statusBar.className = 'status-bar connected';
                statusBar.textContent = `‚úÖ Python —Å–µ—Ä–≤–∏—Å –ø–æ–¥–∫–ª—é—á–µ–Ω | ${connectedCount}/${totalCount} –±–∏—Ä–∂`;
            } else {
                statusBar.className = 'status-bar disconnected';
                statusBar.textContent = '‚ùå –ù–µ—Ç –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ Python —Å–µ—Ä–≤–∏—Å—É';
            }
        }

        async function fetchPrices() {
            try {
                const response = await fetch(`${API_URL}/api/webapp/prices`);
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                
                const result = await response.json();
                
                if (result.success && result.data) {
                    const totalPrices = Object.values(result.data).reduce((sum, ex) => sum + Object.keys(ex).length, 0);
                    const exchangeCount = new Set();
                    Object.values(result.data).forEach(exchanges => {
                        Object.keys(exchanges).forEach(ex => exchangeCount.add(ex));
                    });
                    
                    updateStatus(true, exchangeCount.size, Object.keys(FEES).length);
                    renderArbitrage(result.data);
                } else {
                    throw new Error(result.error || 'No data');
                }
                
            } catch (error) {
                console.error('Fetch error:', error);
                updateStatus(false);
                contentDiv.innerHTML = `
                    <div class="loading">
                        ‚ùå –û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ Python —Å–µ—Ä–≤–∏—Å—É<br><br>
                        –°–µ—Ä–≤–∏—Å –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –¥–æ—Å—Ç—É–ø–µ–Ω –Ω–∞ Railway:<br>
                        <code>${API_URL}</code>
                    </div>
                `;
            }
        }

        function renderArbitrage(data) {
            const results = [];
            const skipped = [];
            const exchangeIds = Object.keys(FEES);
            
            for (const [coin, exchanges] of Object.entries(data)) {
                const allExchangeData = exchangeIds.map(id => {
                    const exData = exchanges[id];
                    return {
                        id,
                        name: EXCHANGE_NAMES[id],
                        fee: FEES[id],
                        data: exData && exData.bid && exData.ask ? { bid: exData.bid, ask: exData.ask } : null,
                        hasData: exData && exData.bid > 0 && exData.ask > 0
                    };
                });
                
                const exchangeData = allExchangeData.filter(e => e.hasData);
                
                if (exchangeData.length < 2) {
                    skipped.push(coin);
                    continue;
                }
                
                let best = { profit: -Infinity, scenario: null, buyEx: null, sellEx: null };
                
                for (const buyEx of exchangeData) {
                    for (const sellEx of exchangeData) {
                        if (buyEx.id === sellEx.id) continue;
                        
                        const profit = calculateProfit(
                            buyEx.data.ask, buyEx.fee,
                            sellEx.data.bid, sellEx.fee,
                            100
                        );
                        
                        if (profit > best.profit) {
                            best = {
                                profit,
                                scenario: {
                                    buyExchange: buyEx.name,
                                    sellExchange: sellEx.name,
                                },
                                buyEx,
                                sellEx
                            };
                        }
                    }
                }
                
                if (best.scenario) {
                    const recs = calculateRecommendations(
                        coin,
                        best.buyEx.data.ask, best.buyEx.fee,
                        best.sellEx.data.bid, best.sellEx.fee
                    );
                    results.push({
                        coin,
                        profit: best.profit,
                        scenario: best.scenario,
                        exchanges: allExchangeData,
                        buyPrice: best.buyEx.data.ask,
                        sellPrice: best.sellEx.data.bid,
                        buyEx: best.buyEx,
                        sellEx: best.sellEx,
                        recommendations: recs,
                    });
                }
            }
            
            results.sort((a, b) => b.profit - a.profit);
            
            const profitableResults = results.filter(r => r.profit >= 0);
            const topResults = profitableResults.length > 0 
                ? profitableResults.slice(0, 100)
                : results.slice(0, 50);
            
            if (topResults.length === 0) {
                contentDiv.innerHTML = `
                    <div class="loading">
                        ‚è≥ –û–∂–∏–¥–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö...<br><br>
                        Python —Å–µ—Ä–≤–∏—Å —Å–æ–±–∏—Ä–∞–µ—Ç —Ü–µ–Ω—ã —Å–æ –≤—Å–µ—Ö –±–∏—Ä–∂
                    </div>
                `;
                return;
            }
            
            const positiveCount = topResults.filter(r => r.profit >= 0).length;
            const totalCoins = Object.keys(data).length;
            const shownCoins = topResults.length;
            const skippedCount = skipped.length;
            
            let summaryText = `–ü–æ–∫–∞–∑–∞–Ω–æ ${shownCoins} –∏–∑ ${totalCoins} –º–æ–Ω–µ—Ç`;
            if (positiveCount > 0) summaryText += ` | ${positiveCount} —Å –ø—Ä–∏–±—ã–ª—å—é`;
            if (skippedCount > 0) summaryText += ` | ${skippedCount} –ø—Ä–æ–ø—É—â–µ–Ω–æ`;
            
            let html = `
                <div class="summary">üèÜ ${summaryText}</div>
                <div class="arbitrage-list">
            `;
            
            for (const result of topResults) {
                const isPositive = result.profit >= 0;
                const profitText = isPositive ? `+${formatPrice(result.profit)}` : formatPrice(result.profit);
                const coinIconUrl = getCoinIconUrl(result.coin);
                const coinFallbackUrl = getCoinFallbackIconUrl(result.coin);
                
                let exchangesHtml = '';
                for (const ex of result.exchanges) {
                    if (ex.hasData) {
                        const isBestBuy = ex.id === result.buyEx.id;
                        const isBestSell = ex.id === result.sellEx.id;
                        const rowClass = isBestBuy ? 'exchange-row best-buy' : (isBestSell ? 'exchange-row best-sell' : 'exchange-row');
                        exchangesHtml += `
                            <div class="${rowClass}">
                                <span class="exchange-name">${ex.name}:${isBestBuy ? ' <span class="best-label">–ü–û–ö–£–ü–ö–ê</span>' : ''}${isBestSell ? ' <span class="best-label">–ü–†–û–î–ê–ñ–ê</span>' : ''}</span>
                                <span class="exchange-prices">
                                    –ü–æ–∫—É–ø–∫–∞ ${formatPrice(ex.data.ask)} / –ü—Ä–æ–¥–∞–∂–∞ ${formatPrice(ex.data.bid)}
                                </span>
                            </div>
                        `;
                    } else {
                        exchangesHtml += `
                            <div class="exchange-row" style="opacity: 0.5;">
                                <span class="exchange-name">${ex.name}:</span>
                                <span class="exchange-prices" style="color: var(--hint-color); font-style: italic;">
                                    ‚è≥ –û–∂–∏–¥–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö...
                                </span>
                            </div>
                        `;
                    }
                }
                
                html += `
                    <div class="arbitrage-card ${isPositive ? 'positive' : 'negative'}">
                        <div class="card-header">
                            <div class="card-header-left">
                                <div class="coin-icon-wrap">
                                    <img src="${coinIconUrl}" alt="${result.coin}" data-fallback="${coinFallbackUrl}" onerror="this.src=this.getAttribute('data-fallback')">
                                </div>
                                <span class="coin-symbol">${result.coin.replace('USDT', '/USDT')}</span>
                            </div>
                            <span class="profit-badge ${isPositive ? 'positive' : 'negative'}">${profitText} USDT</span>
                        </div>
                        <div class="exchanges-grid">${exchangesHtml}</div>
                        <div class="scenario ${isPositive ? '' : 'negative-scenario'}">
                            ${isPositive ? 'üöÄ' : '‚Üí'} <strong>${result.scenario.buyExchange}</strong> ‚Üí <strong>${result.scenario.sellExchange}</strong>
                        </div>
                        
                        <div class="detail-block">
                            <div style="margin-bottom: 6px;"><strong>üìã –î–µ—Ç–∞–ª–∏ —Ä–∞—Å—á–µ—Ç–∞ (–Ω–∞ 100 USDT):</strong></div>
                            <div style="margin-bottom: 2px;">üõí –ü–æ–∫—É–ø–∫–∞ –Ω–∞ ${result.scenario.buyExchange}: ${formatPrice(result.buyPrice)} USDT</div>
                            <div style="margin-bottom: 2px;">üí∏ –ü—Ä–æ–¥–∞–∂–∞ –Ω–∞ ${result.scenario.sellExchange}: ${formatPrice(result.sellPrice)} USDT</div>
                            <div style="margin-bottom: 2px;">üí≥ –ö–æ–º–∏—Å—Å–∏–∏: ${(result.buyEx.fee * 100).toFixed(2)}% + ${(result.sellEx.fee * 100).toFixed(2)}%</div>
                            <div style="color: ${isPositive ? 'var(--positive-color)' : 'var(--negative-color)'}; font-weight: 600;">üí∞ –ß–∏—Å—Ç–∞—è –ø—Ä–∏–±—ã–ª—å: ${profitText} USDT</div>
                        </div>
                        
                        <div class="recommendation">
                            <div class="recommendation-title">üìä –û–ø—Ç–∏–º–∞–ª—å–Ω–∞—è —Å—É–º–º–∞ –≤—Ö–æ–¥–∞ (—Å —É—á–µ—Ç–æ–º –ª–∏–∫–≤–∏–¥–Ω–æ—Å—Ç–∏)</div>
                            <div class="efficiency">
                                <div class="efficiency-value ${result.recommendations.efficiency >= 0 ? 'positive' : 'negative'}">${result.recommendations.efficiency >= 0 ? '+' : ''}${result.recommendations.efficiency.toFixed(3)}%</div>
                                <div class="efficiency-label">–≠—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—å (ROI)</div>
                            </div>
                            ${result.recommendations.isProfitable && result.recommendations.optimalAmount > 0 ? `
                                <div style="margin-top: 10px; padding: 10px; background: rgba(34, 197, 94, 0.1); border-radius: 8px;">
                                    <div style="font-size: 14px; font-weight: 600; color: var(--positive-color); margin-bottom: 6px;">‚≠ê –†–µ–∫–æ–º–µ–Ω–¥—É–µ–º–∞—è —Å—É–º–º–∞: <strong>${result.recommendations.optimalAmount} USDT</strong></div>
                                    <div style="font-size: 12px; color: var(--hint-color);">üí∞ –ü—Ä–∏–±—ã–ª—å: ~${formatPrice(result.recommendations.maxProfit || 0)} USDT ¬∑ –õ–∏–∫–≤–∏–¥–Ω–æ—Å—Ç—å –¥–æ ${Math.round(result.recommendations.liquidity / 1000)}k USDT</div>
                                </div>
                            ` : ''}
                            <div class="recommendation-grid" style="margin-top: 10px;">
                                ${[100, 500, 1000, 2500].map(amount => {
                                    const rec = result.recommendations.recommendations.find(r => r.amount === amount);
                                    if (!rec) return '';
                                    const isOptimal = amount === result.recommendations.optimalAmount;
                                    const profitClass = rec.profit >= 0 ? 'positive' : 'negative';
                                    const profitSign = rec.profit >= 0 ? '+' : '';
                                    const slippageText = rec.slippage > 0.01 ? ` (–ü—Ä–æ—Å–µ–¥–∞–Ω–∏–µ. ${rec.slippage.toFixed(3)}%)` : '';
                                    return `<div class="rec-item"><span class="rec-amount">${amount} USDT${isOptimal ? '<span class="optimal-badge">‚≠ê –û–ø—Ç–∏–º–∞–ª—å–Ω–æ</span>' : ''}</span><span class="rec-profit ${profitClass}">${profitSign}${formatPrice(rec.profit)} USDT${slippageText}</span></div>`;
                                }).join('')}
                            </div>
                            ${result.recommendations.isProfitable ? '<div style="margin-top: 10px; font-size: 11px; color: var(--hint-color);">üí° –°—É–º–º—ã —Å —É—á–µ—Ç–æ–º –ø—Ä–æ—Å–µ–¥–∞–Ω–∏—è –ø—Ä–∏ –ø–æ–∫—É–ø–∫–µ/–ø—Ä–æ–¥–∞–∂–µ</div>' : '<div style="margin-top: 10px; font-size: 12px; color: var(--negative-color);">‚ö†Ô∏è –ê—Ä–±–∏—Ç—Ä–∞–∂ —É–±—ã—Ç–æ—á–Ω—ã–π –ø—Ä–∏ –ª—é–±–æ–π —Å—É–º–º–µ</div>'}
                        </div>
                    </div>
                `;
            }
            
            html += '</div>';
            contentDiv.innerHTML = html;
        }

        refreshBtn.onclick = () => {
            console.log('üîÑ –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö...');
            fetchPrices();
        };

        function startAutoUpdate() {
            if (updateTimer) clearInterval(updateTimer);
            updateTimer = setInterval(fetchPrices, UPDATE_INTERVAL);
        }

        console.log('üöÄ Web App –∑–∞–ø—É—â–µ–Ω (Python CCXT —Ä–µ–∂–∏–º)');
        fetchPrices();
        startAutoUpdate();
    </script>
</body>
</html>

