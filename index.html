<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–ê—Ä–±–∏—Ç—Ä–∞–∂ –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        :root {
            --bg-color: var(--tg-theme-bg-color, #ffffff);
            --text-color: var(--tg-theme-text-color, #000000);
            --hint-color: var(--tg-theme-hint-color, #999999);
            --button-color: var(--tg-theme-button-color, #3390ec);
            --button-text-color: var(--tg-theme-button-text-color, #ffffff);
            --secondary-bg: var(--tg-theme-secondary-bg-color, #f0f0f0);
            --positive-color: #4caf50;
            --negative-color: #ff4444;
            --warning-color: #ff9800;
        }
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-color);
            color: var(--text-color);
            padding: 16px;
            min-height: 100vh;
        }
        
        .container { max-width: 600px; margin: 0 auto; }
        
        h1 {
            font-size: 22px;
            margin-bottom: 16px;
            text-align: center;
        }
        
        .status-bar {
            text-align: center;
            padding: 10px 16px;
            margin-bottom: 12px;
            border-radius: 10px;
            font-size: 13px;
            font-weight: 500;
        }
        
        .status-bar.connected { background: var(--positive-color); color: white; }
        .status-bar.connecting { background: var(--warning-color); color: white; }
        .status-bar.disconnected { background: var(--negative-color); color: white; }
        
        .loading {
            text-align: center;
            padding: 40px 20px;
            color: var(--hint-color);
            font-size: 14px;
            line-height: 1.6;
        }
        
        .arbitrage-list { display: flex; flex-direction: column; gap: 10px; }
        
        .arbitrage-card {
            background: var(--secondary-bg);
            border-radius: 12px;
            padding: 14px 16px;
            border-left: 4px solid var(--button-color);
        }
        
        .arbitrage-card.positive { border-left-color: var(--positive-color); }
        .arbitrage-card.negative { border-left-color: var(--negative-color); }
        
        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .coin-symbol {
            font-size: 17px;
            font-weight: 600;
        }
        
        .profit-badge {
            font-size: 16px;
            font-weight: 700;
            padding: 6px 12px;
            border-radius: 8px;
            color: white;
        }
        
        .profit-badge.positive { background: var(--positive-color); }
        .profit-badge.negative { background: var(--negative-color); }
        
        .exchanges-grid {
            display: flex;
            flex-direction: column;
            gap: 6px;
            font-size: 13px;
        }
        
        .exchange-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .exchange-name { color: var(--hint-color); }
        .exchange-prices { font-weight: 500; }
        
        .scenario {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid rgba(128, 128, 128, 0.2);
            font-size: 13px;
            color: var(--hint-color);
        }
        
        .refresh-btn {
            width: 100%;
            background: var(--button-color);
            color: var(--button-text-color);
            border: none;
            border-radius: 12px;
            padding: 14px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            margin-top: 16px;
        }
        
        .refresh-btn:active { opacity: 0.8; }
        
        .summary {
            text-align: center;
            font-size: 13px;
            color: var(--hint-color);
            margin-bottom: 12px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üí∞ –¢–æ–ø –∞—Ä–±–∏—Ç—Ä–∞–∂–Ω—ã—Ö –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–µ–π</h1>
        <div id="statusBar" class="status-bar disconnected">–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è...</div>
        <div id="content"><div class="loading">‚è≥ –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –±–∏—Ä–∂–∞–º...</div></div>
        <button class="refresh-btn" id="refreshBtn">üîÑ –ü–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–∏—Ç—å</button>
    </div>

    <script>
        'use strict';
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        const CONFIG = {
            TRADE_AMOUNT: 100,        // –û–±—ä–µ–º —Ç–æ—Ä–≥–æ–≤–ª–∏ –≤ USDT
            UPDATE_THROTTLE: 500,     // –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –∏–Ω—Ç–µ—Ä–≤–∞–ª –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è UI (–º—Å)
            RECONNECT_DELAY: 5000,    // –ó–∞–¥–µ—Ä–∂–∫–∞ –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è (–º—Å)
            TOP_RESULTS: 10,          // –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ª—É—á—à–∏—Ö —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
        };

        // –¢–æ–ø-70 –º–æ–Ω–µ—Ç –ø–æ –∫–∞–ø–∏—Ç–∞–ª–∏–∑–∞—Ü–∏–∏ (–±–µ–∑ —Å—Ç–µ–π–±–ª–∫–æ–∏–Ω–æ–≤ USDT/USDC/DAI/USDe/PYUSD)
        const COINS = [
            // –¢–æ–ø-10
            'BTCUSDT', 'ETHUSDT', 'BNBUSDT', 'XRPUSDT', 'SOLUSDT', 
            'TRXUSDT', 'DOGEUSDT', 'STETHUSDT',
            
            // –¢–æ–ø 11-20
            'ADAUSDT', 'LINKUSDT', 'LTCUSDT', 'AVAXUSDT', 'XLMUSDT',
            'XMRUSDT', 'BCHUSDT', 'HBARUSDT', 'SHIBUSDT', 'UNIUSDT',
            
            // –¢–æ–ø 21-40
            'SUIUSDT', 'CROUSDT', 'TONUSDT', 'MNTUSDT', 'ICPUSDT',
            'OPUSDT', 'MATICUSDT', 'FTMUSDT', 'ARBUSDT', 'NEARUSDT',
            'AAVEUSDT', 'PEPEUSDT', 'WLDUSDT', 'ZECUSDT', 'DOTUSDT',
            
            // –¢–æ–ø 41-70
            'SNXUSDT', 'FILUSDT', 'VETUSDT', 'ALGOUSDT', 'FLOWUSDT',
            'RENDERUSDT', 'MKRUSDT', 'BATUSDT', 'QTUMUSDT', 'BSVUSDT',
            'DCRUSDT', 'HNTUSDT', 'NEOUSDT', 'AXSUSDT', 'RUNEUSDT',
            'GALAUSDT', 'KASUSDT', 'INJUSDT', 'ZILUSDT', 'RVNUSDT',
            'SUSHIUSDT', 'ROSEUSDT', 'STXUSDT', 'LRCUSDT', '1INCHUSDT',
            'ARUSDT', 'BNTUSDT',
            
            // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ø—É–ª—è—Ä–Ω—ã–µ
            'APTUSDT', 'SEIUSDT', 'CHZUSDT', 'CRVUSDT', 'LDOUSDT',
            'IMXUSDT', 'SANDUSDT', 'MANAUSDT', 'APEUSDT', 'ETCUSDT',
            'ATOMUSDT', 'FETUSDT', 'XTZUSDT', 'ENJUSDT', 'EGLDUSDT'
        ];

        // –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –±–∏—Ä–∂
        const EXCHANGES = {
            binance: {
                name: 'Binance',
                fee: 0.001,
                wsUrl: 'wss://stream.binance.com:9443/ws/!bookTicker',
                formatSymbol: (coin) => coin,
                parseSymbol: (symbol) => symbol,
            },
            bybit: {
                name: 'Bybit',
                fee: 0.001,
                wsUrl: 'wss://stream.bybit.com/v5/public/spot',
                formatSymbol: (coin) => coin,
                parseSymbol: (symbol) => symbol,
                subscribeMsg: (coins) => ({ op: 'subscribe', args: coins.map(c => `orderbook.1.${c}`) }),
            },
            okx: {
                name: 'OKX',
                fee: 0.001,
                wsUrl: 'wss://ws.okx.com:8443/ws/v5/public',
                formatSymbol: (coin) => coin.replace('USDT', '-USDT'),
                parseSymbol: (symbol) => symbol.replace('-', ''),
                subscribeMsg: (coins) => ({
                    op: 'subscribe',
                    args: coins.map(c => ({ channel: 'tickers', instId: c.replace('USDT', '-USDT') }))
                }),
            },
            kucoin: {
                name: 'KuCoin',
                fee: 0.001,
                wsUrl: 'wss://ws-api-spot.kucoin.com/',
                formatSymbol: (coin) => coin.replace('USDT', '-USDT'),
                parseSymbol: (symbol) => symbol.replace('-', ''),
            },
            bitget: {
                name: 'Bitget',
                fee: 0.001,
                wsUrl: 'wss://ws.bitget.com/v2/ws/public',
                formatSymbol: (coin) => coin,
                parseSymbol: (symbol) => symbol,
            },
            huobi: {
                name: 'Huobi',
                fee: 0.002,
                wsUrl: 'wss://api.huobi.pro/ws',
                formatSymbol: (coin) => coin.toLowerCase(),
                parseSymbol: (symbol) => symbol.toUpperCase(),
            },
            coinbase: {
                name: 'Coinbase',
                fee: 0.006, // Coinbase –∏–º–µ–µ—Ç –±–æ–ª–µ–µ –≤—ã—Å–æ–∫–∏–µ –∫–æ–º–∏—Å—Å–∏–∏
                wsUrl: 'wss://ws-feed.exchange.coinbase.com',
                formatSymbol: (coin) => coin.replace('USDT', '-USDT'),
                parseSymbol: (symbol) => symbol.replace('-', ''),
                subscribeMsg: (coins) => ({
                    type: 'subscribe',
                    product_ids: coins.map(c => c.replace('USDT', '-USDT')),
                    channels: ['ticker']
                }),
            },
            bitfinex: {
                name: 'Bitfinex',
                fee: 0.002,
                wsUrl: 'wss://api-pub.bitfinex.com/ws/2',
                formatSymbol: (coin) => `t${coin}`,
                parseSymbol: (symbol) => symbol.replace('t', ''),
            },
            bingx: {
                name: 'BingX',
                fee: 0.001,
                wsUrl: 'wss://open-api-ws.bingx.com/market',
                formatSymbol: (coin) => coin,
                parseSymbol: (symbol) => symbol,
            },
        };

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // –°–û–°–¢–û–Ø–ù–ò–ï –ü–†–ò–õ–û–ñ–ï–ù–ò–Ø
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        const state = {
            prices: Object.fromEntries(Object.keys(EXCHANGES).map(k => [k, {}])),
            connections: Object.fromEntries(Object.keys(EXCHANGES).map(k => [k, null])),
            status: Object.fromEntries(Object.keys(EXCHANGES).map(k => [k, false])),
            lastUpdate: 0,
            updateTimer: null,
            bitfinexChannels: new Map(),
        };

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // DOM –≠–õ–ï–ú–ï–ù–¢–´
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        const DOM = {
            content: document.getElementById('content'),
            statusBar: document.getElementById('statusBar'),
            refreshBtn: document.getElementById('refreshBtn'),
        };

        // Telegram Web App
        const tg = window.Telegram?.WebApp;
        if (tg) { tg.ready(); tg.expand(); }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // –£–¢–ò–õ–ò–¢–´
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        const Utils = {
            formatPrice: (num, decimals = 2) => {
                if (!Number.isFinite(num)) return 'N/A';
                return num.toFixed(decimals);
            },
            
            formatCoin: (coin) => coin.replace('USDT', '/USDT'),
            
            capitalize: (str) => str.charAt(0).toUpperCase() + str.slice(1),
            
            log: (exchange, msg, data = '') => {
                console.log(`[${exchange.toUpperCase()}] ${msg}`, data);
            },
        };

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // –†–ê–°–ß–ï–¢ –ê–†–ë–ò–¢–†–ê–ñ–ê
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        const ArbitrageCalculator = {
            /**
             * –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ—Ç –ø—Ä–∏–±—ã–ª—å –æ—Ç –∞—Ä–±–∏—Ç—Ä–∞–∂–∞
             * @param {number} buyPrice - –¶–µ–Ω–∞ –ø–æ–∫—É–ø–∫–∏ (ask –Ω–∞ –±–∏—Ä–∂–µ –ø–æ–∫—É–ø–∫–∏)
             * @param {number} buyFee - –ö–æ–º–∏—Å—Å–∏—è –ø–æ–∫—É–ø–∫–∏ (0.001 = 0.1%)
             * @param {number} sellPrice - –¶–µ–Ω–∞ –ø—Ä–æ–¥–∞–∂–∏ (bid –Ω–∞ –±–∏—Ä–∂–µ –ø—Ä–æ–¥–∞–∂–∏)
             * @param {number} sellFee - –ö–æ–º–∏—Å—Å–∏—è –ø—Ä–æ–¥–∞–∂–∏
             * @param {number} amount - –°—É–º–º–∞ –≤ USDT
             * @returns {number} –ü—Ä–∏–±—ã–ª—å –≤ USDT
             */
            calculate(buyPrice, buyFee, sellPrice, sellFee, amount) {
                if (!buyPrice || !sellPrice || buyPrice <= 0 || sellPrice <= 0) {
                    return -Infinity;
                }
                
                // 1. –ü–æ–∫—É–ø–∫–∞: USDT ‚Üí Crypto
                const afterBuyFee = amount * (1 - buyFee);
                const cryptoAmount = afterBuyFee / buyPrice;
                
                // 2. –ü—Ä–æ–¥–∞–∂–∞: Crypto ‚Üí USDT
                const grossProceeds = cryptoAmount * sellPrice;
                const netProceeds = grossProceeds * (1 - sellFee);
                
                // 3. –ò—Ç–æ–≥–æ–≤–∞—è –ø—Ä–∏–±—ã–ª—å
                return netProceeds - amount;
            },
            
            /**
             * –ù–∞—Ö–æ–¥–∏—Ç –ª—É—á—à—É—é –∞—Ä–±–∏—Ç—Ä–∞–∂–Ω—É—é –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –¥–ª—è –º–æ–Ω–µ—Ç—ã
             */
            findBestOpportunity(coin, exchangeData) {
                const validExchanges = exchangeData.filter(e => 
                    e.data?.bid > 0 && e.data?.ask > 0 && 
                    Number.isFinite(e.data.bid) && Number.isFinite(e.data.ask)
                );
                
                if (validExchanges.length < 2) return null;
                
                let best = { profit: -Infinity, scenario: null };
                
                for (const buyEx of validExchanges) {
                    for (const sellEx of validExchanges) {
                        if (buyEx.id === sellEx.id) continue;
                        
                        const profit = this.calculate(
                            buyEx.data.ask,
                            buyEx.fee,
                            sellEx.data.bid,
                            sellEx.fee,
                            CONFIG.TRADE_AMOUNT
                        );
                        
                        if (profit > best.profit) {
                            best = {
                                profit,
                                scenario: {
                                    buyExchange: buyEx.name,
                                    sellExchange: sellEx.name,
                                    buyPrice: buyEx.data.ask,
                                    sellPrice: sellEx.data.bid,
                                }
                            };
                        }
                    }
                }
                
                return best.scenario ? {
                    coin,
                    profit: best.profit,
                    scenario: best.scenario,
                    exchanges: validExchanges,
                } : null;
            }
        };

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // WEBSOCKET –ú–ï–ù–ï–î–ñ–ï–†
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        const WSManager = {
            init(exchangeId) {
                const config = EXCHANGES[exchangeId];
                if (!config?.wsUrl) return;
                
                if (state.connections[exchangeId]?.readyState === WebSocket.OPEN) return;
                
                try {
                    const ws = new WebSocket(config.wsUrl);
                    state.connections[exchangeId] = ws;
                    
                    ws.onopen = () => this.onOpen(exchangeId, ws, config);
                    ws.onmessage = (e) => this.onMessage(exchangeId, e, config);
                    ws.onerror = () => this.onError(exchangeId);
                    ws.onclose = () => this.onClose(exchangeId);
                } catch (err) {
                    console.error(`[${exchangeId}] WebSocket creation failed:`, err);
                    state.status[exchangeId] = false;
                    UI.updateStatusBar();
                }
            },
            
            onOpen(exchangeId, ws, config) {
                Utils.log(exchangeId, '‚úÖ Connected');
                state.status[exchangeId] = true;
                UI.updateStatusBar();
                
                // –ü–æ–¥–ø–∏—Å–∫–∞ –Ω–∞ –¥–∞–Ω–Ω—ã–µ
                this.subscribe(exchangeId, ws, config);
            },
            
            subscribe(exchangeId, ws, config) {
                switch (exchangeId) {
                    case 'binance':
                        // Binance –∏—Å–ø–æ–ª—å–∑—É–µ—Ç stream –¥–ª—è –≤—Å–µ—Ö —Ç–∏–∫–µ—Ä–æ–≤ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏
                        break;
                        
                    case 'bybit':
                        ws.send(JSON.stringify({
                            op: 'subscribe',
                            args: COINS.map(c => `orderbook.1.${c}`)
                        }));
                        break;
                        
                    case 'okx':
                        ws.send(JSON.stringify({
                            op: 'subscribe',
                            args: COINS.map(c => ({ 
                                channel: 'tickers', 
                                instId: c.replace('USDT', '-USDT') 
                            }))
                        }));
                        break;
                        
                    case 'kucoin':
                        // KuCoin —Ç—Ä–µ–±—É–µ—Ç –ø–æ—Å—Ç–µ–ø–µ–Ω–Ω–æ–π –ø–æ–¥–ø–∏—Å–∫–∏
                        setTimeout(() => {
                            COINS.forEach((coin, i) => {
                                setTimeout(() => {
                                    if (ws.readyState === WebSocket.OPEN) {
                                        ws.send(JSON.stringify({
                                            id: Date.now() + i,
                                            type: 'subscribe',
                                            topic: `/market/ticker:${coin.replace('USDT', '-USDT')}`,
                                            privateChannel: false,
                                            response: true
                                        }));
                                    }
                                }, i * 50);
                            });
                        }, 500);
                        break;
                        
                    case 'bitget':
                        COINS.forEach(coin => {
                            ws.send(JSON.stringify({
                                op: 'subscribe',
                                args: [{ instType: 'SPOT', channel: 'ticker', instId: coin }]
                            }));
                        });
                        break;
                        
                    case 'huobi':
                        COINS.forEach(coin => {
                            ws.send(JSON.stringify({
                                sub: `market.${coin.toLowerCase()}.ticker`,
                                id: `${coin}_${Date.now()}`
                            }));
                        });
                        break;
                        
                    case 'coinbase':
                        ws.send(JSON.stringify({
                            type: 'subscribe',
                            product_ids: COINS.map(c => c.replace('USDT', '-USDT')),
                            channels: ['ticker']
                        }));
                        break;
                        
                    case 'bitfinex':
                        COINS.forEach(coin => {
                            ws.send(JSON.stringify({
                                event: 'subscribe',
                                channel: 'ticker',
                                symbol: `t${coin}`
                            }));
                        });
                        break;
                        
                    case 'bingx':
                        COINS.forEach(coin => {
                            ws.send(JSON.stringify({
                                id: Date.now().toString(),
                                reqType: 'sub',
                                dataType: `${coin}@ticker`
                            }));
                        });
                        break;
                }
            },
            
            async onMessage(exchangeId, event, config) {
                try {
                    let data;
                    
                    // –û–±—Ä–∞–±–æ—Ç–∫–∞ Blob –¥–∞–Ω–Ω—ã—Ö (Huobi, BingX)
                    if (event.data instanceof Blob) {
                        const text = await event.data.text();
                        data = JSON.parse(text);
                    } else {
                        data = JSON.parse(event.data);
                    }
                    
                    // –ü–∞—Ä—Å–∏–Ω–≥ –¥–∞–Ω–Ω—ã—Ö –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –±–∏—Ä–∂–∏
                    const parsed = this.parseMessage(exchangeId, data);
                    
                    if (parsed?.symbol && parsed?.bid && parsed?.ask) {
                        state.prices[exchangeId][parsed.symbol] = {
                            bid: parsed.bid,
                            ask: parsed.ask,
                            timestamp: Date.now()
                        };
                        UI.scheduleUpdate();
                    }
                } catch (err) {
                    // –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º –æ—à–∏–±–∫–∏ –ø–∞—Ä—Å–∏–Ω–≥–∞ –¥–ª—è Blob
                }
            },
            
            parseMessage(exchangeId, data) {
                switch (exchangeId) {
                    case 'binance':
                        if (data.s && data.b && data.a && COINS.includes(data.s)) {
                            return { symbol: data.s, bid: parseFloat(data.b), ask: parseFloat(data.a) };
                        }
                        break;
                        
                    case 'bybit':
                        if (data.topic?.startsWith('orderbook.1.')) {
                            const symbol = data.topic.replace('orderbook.1.', '');
                            if (COINS.includes(symbol) && data.data?.b?.[0] && data.data?.a?.[0]) {
                                return { symbol, bid: parseFloat(data.data.b[0][0]), ask: parseFloat(data.data.a[0][0]) };
                            }
                        }
                        break;
                        
                    case 'okx':
                        if (data.data?.[0]?.instId) {
                            const symbol = data.data[0].instId.replace('-', '');
                            if (COINS.includes(symbol)) {
                                return { symbol, bid: parseFloat(data.data[0].bidPx), ask: parseFloat(data.data[0].askPx) };
                            }
                        }
                        break;
                        
                    case 'kucoin':
                        // –û–±—Ä–∞–±–æ—Ç–∫–∞ ping/pong
                        if (data.type === 'ping') {
                            state.connections[exchangeId]?.send(JSON.stringify({ type: 'pong', id: data.id }));
                            return null;
                        }
                        if (data.type === 'message' && data.data) {
                            const symbol = data.topic?.split(':')[1]?.replace('-', '') || data.data.symbol?.replace('-', '');
                            if (symbol && COINS.includes(symbol)) {
                                const bid = parseFloat(data.data.bestBid || data.data.buy || 0);
                                const ask = parseFloat(data.data.bestAsk || data.data.sell || 0);
                                if (bid > 0 && ask > 0) return { symbol, bid, ask };
                            }
                        }
                        break;
                        
                    case 'bitget':
                        if (data.data?.[0] || data.data) {
                            const ticker = Array.isArray(data.data) ? data.data[0] : data.data;
                            const symbol = ticker?.instId || data.arg?.instId;
                            if (symbol && COINS.includes(symbol)) {
                                const bid = parseFloat(ticker.bestBid || ticker.bidPr || 0);
                                const ask = parseFloat(ticker.bestAsk || ticker.askPr || 0);
                                if (bid > 0 && ask > 0) return { symbol, bid, ask };
                            }
                        }
                        break;
                        
                    case 'huobi':
                        // –û–±—Ä–∞–±–æ—Ç–∫–∞ ping
                        if (data.ping) {
                            state.connections[exchangeId]?.send(JSON.stringify({ pong: data.ping }));
                            return null;
                        }
                        if (data.tick && data.ch) {
                            const symbol = data.ch.replace('market.', '').replace('.ticker', '').toUpperCase();
                            if (COINS.includes(symbol)) {
                                const bid = Array.isArray(data.tick.bid) ? data.tick.bid[0] : data.tick.bid;
                                const ask = Array.isArray(data.tick.ask) ? data.tick.ask[0] : data.tick.ask;
                                if (bid > 0 && ask > 0) return { symbol, bid: parseFloat(bid), ask: parseFloat(ask) };
                            }
                        }
                        break;
                        
                    case 'coinbase':
                        if (data.type === 'ticker' && data.product_id) {
                            const symbol = data.product_id.replace('-', '');
                            if (COINS.includes(symbol) && data.best_bid && data.best_ask) {
                                return { symbol, bid: parseFloat(data.best_bid), ask: parseFloat(data.best_ask) };
                            }
                        }
                        break;
                        
                    case 'bitfinex':
                        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –ø–æ–¥–ø–∏—Å–∫–∏
                        if (data.event === 'subscribed' && data.chanId && data.symbol) {
                            state.bitfinexChannels.set(data.chanId, data.symbol.replace('t', ''));
                            return null;
                        }
                        // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ç–∏–∫–µ—Ä–∞
                        if (Array.isArray(data) && data.length >= 2 && Array.isArray(data[1]) && data[1].length >= 10) {
                            const symbol = state.bitfinexChannels.get(data[0]);
                            if (symbol && COINS.includes(symbol)) {
                                return { symbol, bid: parseFloat(data[1][0]), ask: parseFloat(data[1][2]) };
                            }
                        }
                        break;
                        
                    case 'bingx':
                        if (data.data?.s && data.data?.b && data.data?.a) {
                            const symbol = data.data.s;
                            if (COINS.includes(symbol)) {
                                return { symbol, bid: parseFloat(data.data.b), ask: parseFloat(data.data.a) };
                            }
                        }
                        break;
                }
                return null;
            },
            
            onError(exchangeId) {
                state.status[exchangeId] = false;
                UI.updateStatusBar();
            },
            
            onClose(exchangeId) {
                Utils.log(exchangeId, '‚ùå Disconnected, reconnecting...');
                state.status[exchangeId] = false;
                UI.updateStatusBar();
                setTimeout(() => this.init(exchangeId), CONFIG.RECONNECT_DELAY);
            },
            
            initAll() {
                Object.keys(EXCHANGES).forEach(id => this.init(id));
            },
            
            closeAll() {
                Object.keys(state.connections).forEach(id => {
                    if (state.connections[id]) {
                        state.connections[id].close();
                        state.connections[id] = null;
                    }
                });
            }
        };

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // UI –ú–ï–ù–ï–î–ñ–ï–†
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        const UI = {
            updateStatusBar() {
                const connected = Object.values(state.status).filter(Boolean).length;
                const total = Object.keys(EXCHANGES).length;
                
                let className = 'disconnected';
                let text = `‚ùå –ù–µ—Ç –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–π`;
                
                if (connected === total) {
                    className = 'connected';
                    text = `‚úÖ –í—Å–µ ${total} –±–∏—Ä–∂ –ø–æ–¥–∫–ª—é—á–µ–Ω—ã`;
                } else if (connected > 0) {
                    className = 'connecting';
                    text = `‚è≥ –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ: ${connected}/${total} –±–∏—Ä–∂`;
                }
                
                DOM.statusBar.className = `status-bar ${className}`;
                DOM.statusBar.textContent = text;
            },
            
            scheduleUpdate() {
                const now = Date.now();
                if (now - state.lastUpdate < CONFIG.UPDATE_THROTTLE) {
                    if (state.updateTimer) clearTimeout(state.updateTimer);
                    state.updateTimer = setTimeout(() => {
                        state.lastUpdate = Date.now();
                        this.render();
                    }, CONFIG.UPDATE_THROTTLE);
                    return;
                }
                
                state.lastUpdate = now;
                if (state.updateTimer) clearTimeout(state.updateTimer);
                this.render();
            },
            
            render() {
                const results = [];
                
                for (const coin of COINS) {
                    const exchangeData = Object.entries(state.prices)
                        .map(([id, prices]) => ({
                            id,
                            name: EXCHANGES[id].name,
                            fee: EXCHANGES[id].fee,
                            data: prices[coin]
                        }))
                        .filter(e => e.data?.bid > 0 && e.data?.ask > 0);
                    
                    if (exchangeData.length >= 2) {
                        const opportunity = ArbitrageCalculator.findBestOpportunity(coin, exchangeData);
                        if (opportunity) results.push(opportunity);
                    }
                }
                
                // –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –ø–æ –ø—Ä–∏–±—ã–ª–∏
                results.sort((a, b) => b.profit - a.profit);
                const topResults = results.slice(0, CONFIG.TOP_RESULTS);
                
                if (topResults.length === 0) {
                    const totalPrices = Object.values(state.prices).reduce((sum, p) => sum + Object.keys(p).length, 0);
                    DOM.content.innerHTML = `
                        <div class="loading">
                            ${totalPrices === 0 
                                ? '‚è≥ –û–∂–∏–¥–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö —Å –±–∏—Ä–∂...' 
                                : '‚ö†Ô∏è –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —Ä–∞—Å—á–µ—Ç–∞ –∞—Ä–±–∏—Ç—Ä–∞–∂–∞'}
                            <br><br>
                            –ü–æ–ª—É—á–µ–Ω–æ —Ü–µ–Ω: ${totalPrices}
                        </div>
                    `;
                    return;
                }
                
                const positiveCount = topResults.filter(r => r.profit >= 0).length;
                
                let html = `
                    <div class="summary">
                        üèÜ –¢–û–ü-${topResults.length} –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–µ–π | ${positiveCount} —Å –ø—Ä–∏–±—ã–ª—å—é
                    </div>
                    <div class="arbitrage-list">
                `;
                
                for (const result of topResults) {
                    const isPositive = result.profit >= 0;
                    const profitText = isPositive ? `+${Utils.formatPrice(result.profit)}` : Utils.formatPrice(result.profit);
                    
                    let exchangesHtml = '';
                    for (const ex of result.exchanges) {
                        exchangesHtml += `
                            <div class="exchange-row">
                                <span class="exchange-name">${ex.name}:</span>
                                <span class="exchange-prices">
                                    –ü–æ–∫—É–ø–∫–∞ ${Utils.formatPrice(ex.data.ask)} | –ü—Ä–æ–¥–∞–∂–∞ ${Utils.formatPrice(ex.data.bid)}
                                </span>
                            </div>
                        `;
                    }
                    
                    html += `
                        <div class="arbitrage-card ${isPositive ? 'positive' : 'negative'}">
                            <div class="card-header">
                                <span class="coin-symbol">${Utils.formatCoin(result.coin)}</span>
                                <span class="profit-badge ${isPositive ? 'positive' : 'negative'}">${profitText} USDT</span>
                            </div>
                            <div class="exchanges-grid">${exchangesHtml}</div>
                            <div class="scenario">
                                üí° ${result.scenario.buyExchange} ‚Üí ${result.scenario.sellExchange} 
                                (${Utils.formatPrice(result.profit)} USDT)
                            </div>
                        </div>
                    `;
                }
                
                html += '</div>';
                DOM.content.innerHTML = html;
            }
        };

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        function init() {
            console.log('üöÄ –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∞—Ä–±–∏—Ç—Ä–∞–∂–Ω–æ–≥–æ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è...');
            console.log(`üìä –ú–æ–Ω–µ—Ç: ${COINS.length}, –ë–∏—Ä–∂: ${Object.keys(EXCHANGES).length}`);
            
            UI.updateStatusBar();
            WSManager.initAll();
            
            DOM.refreshBtn.onclick = () => {
                console.log('üîÑ –ü–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ...');
                WSManager.closeAll();
                
                // –û—á–∏—Å—Ç–∫–∞ —Å–æ—Å—Ç–æ—è–Ω–∏—è
                Object.keys(state.prices).forEach(k => state.prices[k] = {});
                Object.keys(state.status).forEach(k => state.status[k] = false);
                state.bitfinexChannels.clear();
                
                DOM.content.innerHTML = '<div class="loading">‚è≥ –ü–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –±–∏—Ä–∂–∞–º...</div>';
                UI.updateStatusBar();
                
                setTimeout(() => WSManager.initAll(), 1000);
            };
        }

        // –ó–∞–ø—É—Å–∫ –ø–æ—Å–ª–µ –∑–∞–≥—Ä—É–∑–∫–∏ DOM
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }
    </script>
</body>
</html>
