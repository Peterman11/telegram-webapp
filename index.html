<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–ê—Ä–±–∏—Ç—Ä–∞–∂ –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
    <style>
        :root {
            --bg-color: var(--tg-theme-bg-color, #ffffff);
            --text-color: var(--tg-theme-text-color, #000000);
            --hint-color: var(--tg-theme-hint-color, #999999);
            --button-color: var(--tg-theme-button-color, #3390ec);
            --button-text-color: var(--tg-theme-button-text-color, #ffffff);
            --secondary-bg: var(--tg-theme-secondary-bg-color, #f0f0f0);
            --positive-color: #4caf50;
            --negative-color: #ff4444;
            --warning-color: #ff9800;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-color);
            color: var(--text-color);
            padding: 16px;
            min-height: 100vh;
        }
        .container { max-width: 600px; margin: 0 auto; }
        h1 { font-size: 22px; margin-bottom: 16px; text-align: center; }
        .status-bar {
            text-align: center;
            padding: 10px 16px;
            margin-bottom: 12px;
            border-radius: 10px;
            font-size: 13px;
            font-weight: 500;
        }
        .status-bar.connected { background: var(--positive-color); color: white; }
        .status-bar.connecting { background: var(--warning-color); color: white; }
        .status-bar.disconnected { background: var(--negative-color); color: white; }
        .loading {
            text-align: center;
            padding: 40px 20px;
            color: var(--hint-color);
            font-size: 14px;
            line-height: 1.6;
        }
        .arbitrage-list { display: flex; flex-direction: column; gap: 12px; }
        .arbitrage-card {
            background: var(--secondary-bg);
            border-radius: 12px;
            padding: 14px 16px;
            border-left: 4px solid var(--button-color);
        }
        .arbitrage-card.positive { border-left-color: var(--positive-color); }
        .arbitrage-card.negative { border-left-color: var(--negative-color); }
        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        .coin-symbol { font-size: 17px; font-weight: 600; }
        .profit-badge {
            font-size: 16px;
            font-weight: 700;
            padding: 6px 12px;
            border-radius: 8px;
            color: white;
        }
        .profit-badge.positive { background: var(--positive-color); }
        .profit-badge.negative { background: var(--negative-color); }
        .exchanges-grid { display: flex; flex-direction: column; gap: 6px; font-size: 13px; }
        .exchange-row { display: flex; justify-content: space-between; align-items: center; }
        .exchange-name { color: var(--hint-color); }
        .exchange-prices { font-weight: 500; }
        .scenario {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid rgba(128, 128, 128, 0.2);
            font-size: 13px;
            color: var(--hint-color);
        }
        
        /* –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –ø–æ —Å—É–º–º–µ */
        .recommendation {
            margin-top: 12px;
            padding: 12px;
            background: rgba(51, 144, 236, 0.1);
            border-radius: 8px;
            font-size: 13px;
        }
        .recommendation-title {
            font-weight: 600;
            color: var(--button-color);
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .recommendation-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
        }
        .rec-item {
            display: flex;
            justify-content: space-between;
            padding: 6px 8px;
            background: var(--bg-color);
            border-radius: 6px;
        }
        .rec-amount { color: var(--hint-color); }
        .rec-profit { font-weight: 600; }
        .rec-profit.positive { color: var(--positive-color); }
        .rec-profit.negative { color: var(--negative-color); }
        .optimal-badge {
            background: var(--positive-color);
            color: white;
            font-size: 11px;
            padding: 2px 6px;
            border-radius: 4px;
            margin-left: 6px;
        }
        .efficiency {
            margin-top: 8px;
            padding: 8px;
            background: var(--bg-color);
            border-radius: 6px;
            text-align: center;
        }
        .efficiency-value {
            font-size: 18px;
            font-weight: 700;
        }
        .efficiency-label {
            font-size: 11px;
            color: var(--hint-color);
        }
        
        .refresh-btn {
            width: 100%;
            background: var(--button-color);
            color: var(--button-text-color);
            border: none;
            border-radius: 12px;
            padding: 14px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            margin-top: 16px;
        }
        .refresh-btn:active { opacity: 0.8; }
        .summary { text-align: center; font-size: 13px; color: var(--hint-color); margin-bottom: 12px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üí∞ –¢–æ–ø –∞—Ä–±–∏—Ç—Ä–∞–∂–Ω—ã—Ö –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–µ–π</h1>
        <div id="statusBar" class="status-bar disconnected">–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è...</div>
        <div id="content"><div class="loading">‚è≥ –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –±–∏—Ä–∂–∞–º...</div></div>
        <button class="refresh-btn" id="refreshBtn">üîÑ –ü–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–∏—Ç—å</button>
    </div>

    <script>
        'use strict';
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–Ø
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        const CONFIG = {
            TRADE_AMOUNT: 100,
            UPDATE_THROTTLE: 500,
            RECONNECT_DELAY: 5000,
            TOP_RESULTS: 10,
            // –°—É–º–º—ã –¥–ª—è —Ä–∞—Å—á–µ—Ç–∞ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π
            AMOUNTS: [50, 100, 250, 500, 1000, 2500, 5000],
        };

        const COINS = [
            'BTCUSDT', 'ETHUSDT', 'BNBUSDT', 'XRPUSDT', 'SOLUSDT', 
            'TRXUSDT', 'DOGEUSDT', 'ADAUSDT', 'LINKUSDT', 'LTCUSDT', 
            'AVAXUSDT', 'XLMUSDT', 'XMRUSDT', 'BCHUSDT', 'DOTUSDT',
            'UNIUSDT', 'SHIBUSDT', 'ATOMUSDT', 'NEARUSDT', 'AAVEUSDT',
            'APTUSDT', 'ARBUSDT', 'OPUSDT', 'FILUSDT', 'ICPUSDT',
            'ETCUSDT', 'ALGOUSDT', 'VETUSDT', 'MATICUSDT', 'INJUSDT',
            'FTMUSDT', 'AXSUSDT', 'SUIUSDT', 'SEIUSDT', 'TONUSDT',
            'PEPEUSDT', 'MKRUSDT', 'STXUSDT', 'CRVUSDT', 'LDOUSDT'
        ];

        const FEES = {
            binance: 0.001,
            bybit: 0.001,
            okx: 0.001,
            kucoin: 0.001,
            bitget: 0.001,
            huobi: 0.002,
            coinbase: 0.006,
            bitfinex: 0.002,
            bingx: 0.001,
        };

        const EXCHANGE_NAMES = {
            binance: 'Binance',
            bybit: 'Bybit',
            okx: 'OKX',
            kucoin: 'KuCoin',
            bitget: 'Bitget',
            huobi: 'Huobi',
            coinbase: 'Coinbase',
            bitfinex: 'Bitfinex',
            bingx: 'BingX',
        };

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // –°–û–°–¢–û–Ø–ù–ò–ï
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        const prices = {};
        const wsConnections = {};
        const connectionStatus = {};
        const bitfinexChannels = new Map();
        
        Object.keys(FEES).forEach(ex => {
            prices[ex] = {};
            connectionStatus[ex] = false;
        });

        let lastUpdate = 0;
        let updateTimer = null;

        const contentDiv = document.getElementById('content');
        const statusBar = document.getElementById('statusBar');
        const refreshBtn = document.getElementById('refreshBtn');

        const tg = window.Telegram?.WebApp;
        if (tg) { tg.ready(); tg.expand(); }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // –£–¢–ò–õ–ò–¢–´
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        function log(exchange, msg, data = '') {
            console.log(`[${exchange.toUpperCase()}] ${msg}`, data);
        }

        function formatPrice(num) {
            if (!Number.isFinite(num)) return 'N/A';
            return num.toFixed(2);
        }

        function savePrice(exchange, symbol, bid, ask) {
            if (bid > 0 && ask > 0 && COINS.includes(symbol)) {
                prices[exchange][symbol] = { bid, ask, timestamp: Date.now() };
                scheduleUpdate();
            }
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // –†–ê–°–ß–ï–¢ –ê–†–ë–ò–¢–†–ê–ñ–ê
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        function calculateProfit(buyPrice, buyFee, sellPrice, sellFee, amount) {
            if (!buyPrice || !sellPrice || buyPrice <= 0 || sellPrice <= 0) return -Infinity;
            const afterBuyFee = amount * (1 - buyFee);
            const crypto = afterBuyFee / buyPrice;
            const gross = crypto * sellPrice;
            const net = gross * (1 - sellFee);
            return net - amount;
        }

        /**
         * –†–∞—Å—á–µ—Ç —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏ –∞—Ä–±–∏—Ç—Ä–∞–∂–∞ (–≤ –ø—Ä–æ—Ü–µ–Ω—Ç–∞—Ö)
         * –ü–æ–∫–∞–∑—ã–≤–∞–µ—Ç, –∫–∞–∫–æ–π –ø—Ä–æ—Ü–µ–Ω—Ç –æ—Ç —Å—É–º–º—ã —Å–æ—Å—Ç–∞–≤–ª—è–µ—Ç –ø—Ä–∏–±—ã–ª—å
         */
        function calculateEfficiency(buyPrice, buyFee, sellPrice, sellFee) {
            // –≠—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—å = (sellPrice/buyPrice) * (1-buyFee) * (1-sellFee) - 1
            // –ù–µ –∑–∞–≤–∏—Å–∏—Ç –æ—Ç —Å—É–º–º—ã!
            const ratio = (sellPrice / buyPrice) * (1 - buyFee) * (1 - sellFee);
            return (ratio - 1) * 100;
        }

        /**
         * –†–∞—Å—á–µ—Ç –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–π —Å—É–º–º—ã –¥–ª—è –±–µ–∑—É–±—ã—Ç–æ—á–Ω–æ—Å—Ç–∏
         * (—Å —É—á–µ—Ç–æ–º –º–∏–Ω–∏–º–∞–ª—å–Ω—ã—Ö –∫–æ–º–∏—Å—Å–∏–π –±–∏—Ä–∂, –µ—Å–ª–∏ –µ—Å—Ç—å)
         */
        function calculateMinAmount(buyPrice, buyFee, sellPrice, sellFee, minFee = 0) {
            const efficiency = calculateEfficiency(buyPrice, buyFee, sellPrice, sellFee);
            if (efficiency <= 0) return Infinity; // –í—Å–µ–≥–¥–∞ —É–±—ã—Ç–æ—á–Ω–æ
            // minAmount * efficiency/100 >= minFee
            return minFee > 0 ? (minFee * 100 / efficiency) : 0;
        }

        /**
         * –†–∞—Å—á–µ—Ç —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π –ø–æ —Å—É–º–º–∞–º
         */
        function calculateRecommendations(buyPrice, buyFee, sellPrice, sellFee) {
            const efficiency = calculateEfficiency(buyPrice, buyFee, sellPrice, sellFee);
            const isProfitable = efficiency > 0;
            
            const recommendations = CONFIG.AMOUNTS.map(amount => ({
                amount,
                profit: calculateProfit(buyPrice, buyFee, sellPrice, sellFee, amount),
                roi: efficiency // ROI –æ–¥–∏–Ω–∞–∫–æ–≤ –¥–ª—è –≤—Å–µ—Ö —Å—É–º–º
            }));
            
            // –ù–∞—Ö–æ–¥–∏–º –æ–ø—Ç–∏–º–∞–ª—å–Ω—É—é —Å—É–º–º—É
            // –î–ª—è –∞—Ä–±–∏—Ç—Ä–∞–∂–∞ –±–µ–∑ —É—á–µ—Ç–∞ –≥–ª—É–±–∏–Ω—ã —Å—Ç–∞–∫–∞–Ω–∞ - —á–µ–º –±–æ–ª—å—à–µ —Å—É–º–º–∞, —Ç–µ–º –±–æ–ª—å—à–µ –∞–±—Å–æ–ª—é—Ç–Ω–∞—è –ø—Ä–∏–±—ã–ª—å
            // –ù–æ –ø—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏ —Ä–µ–∫–æ–º–µ–Ω–¥—É–µ–º 500-1000 USDT –∫–∞–∫ –±–∞–ª–∞–Ω—Å –º–µ–∂–¥—É –ø—Ä–∏–±—ã–ª—å—é –∏ —Ä–∏—Å–∫–æ–º
            let optimalAmount = isProfitable ? 500 : 0;
            if (efficiency > 0.5) optimalAmount = 1000; // –ü—Ä–∏ –≤—ã—Å–æ–∫–æ–π —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏ –º–æ–∂–Ω–æ –±–æ–ª—å—à–µ
            if (efficiency > 1) optimalAmount = 2500;
            
            return {
                efficiency,
                isProfitable,
                optimalAmount,
                recommendations
            };
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // BINANCE WebSocket
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        function initBinance() {
            if (wsConnections.binance?.readyState === WebSocket.OPEN) return;
            
            const ws = new WebSocket('wss://stream.binance.com:9443/ws/!bookTicker');
            wsConnections.binance = ws;
            
            ws.onopen = () => {
                log('binance', '‚úÖ Connected');
                connectionStatus.binance = true;
                updateStatusBar();
            };
            
            ws.onmessage = (e) => {
                try {
                    const d = JSON.parse(e.data);
                    if (d.s && d.b && d.a) {
                        savePrice('binance', d.s, parseFloat(d.b), parseFloat(d.a));
                    }
                } catch (err) {}
            };
            
            ws.onerror = ws.onclose = () => {
                connectionStatus.binance = false;
                updateStatusBar();
                setTimeout(initBinance, CONFIG.RECONNECT_DELAY);
            };
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // BYBIT WebSocket
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        function initBybit() {
            if (wsConnections.bybit?.readyState === WebSocket.OPEN) return;
            
            const ws = new WebSocket('wss://stream.bybit.com/v5/public/spot');
            wsConnections.bybit = ws;
            
            ws.onopen = () => {
                log('bybit', '‚úÖ Connected');
                connectionStatus.bybit = true;
                updateStatusBar();
                ws.send(JSON.stringify({
                    op: 'subscribe',
                    args: COINS.map(c => `orderbook.1.${c}`)
                }));
            };
            
            ws.onmessage = (e) => {
                try {
                    const d = JSON.parse(e.data);
                    if (d.topic?.startsWith('orderbook.1.')) {
                        const symbol = d.topic.replace('orderbook.1.', '');
                        if (d.data?.b?.[0] && d.data?.a?.[0]) {
                            savePrice('bybit', symbol, parseFloat(d.data.b[0][0]), parseFloat(d.data.a[0][0]));
                        }
                    }
                } catch (err) {}
            };
            
            ws.onerror = ws.onclose = () => {
                connectionStatus.bybit = false;
                updateStatusBar();
                setTimeout(initBybit, CONFIG.RECONNECT_DELAY);
            };
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // OKX WebSocket
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        function initOkx() {
            if (wsConnections.okx?.readyState === WebSocket.OPEN) return;
            
            const ws = new WebSocket('wss://ws.okx.com:8443/ws/v5/public');
            wsConnections.okx = ws;
            
            ws.onopen = () => {
                log('okx', '‚úÖ Connected');
                connectionStatus.okx = true;
                updateStatusBar();
                ws.send(JSON.stringify({
                    op: 'subscribe',
                    args: COINS.map(c => ({ channel: 'tickers', instId: c.replace('USDT', '-USDT') }))
                }));
            };
            
            ws.onmessage = (e) => {
                try {
                    const d = JSON.parse(e.data);
                    if (d.data?.[0]?.instId) {
                        const symbol = d.data[0].instId.replace('-', '');
                        savePrice('okx', symbol, parseFloat(d.data[0].bidPx), parseFloat(d.data[0].askPx));
                    }
                } catch (err) {}
            };
            
            ws.onerror = ws.onclose = () => {
                connectionStatus.okx = false;
                updateStatusBar();
                setTimeout(initOkx, CONFIG.RECONNECT_DELAY);
            };
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // KUCOIN WebSocket
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        async function initKucoin() {
            if (wsConnections.kucoin?.readyState === WebSocket.OPEN) return;
            
            try {
                const resp = await fetch('https://api.kucoin.com/api/v1/bullet-public', { method: 'POST' });
                const json = await resp.json();
                
                if (json.code !== '200000' || !json.data?.token) {
                    log('kucoin', '‚ùå Failed to get token');
                    connectionStatus.kucoin = false;
                    updateStatusBar();
                    setTimeout(initKucoin, CONFIG.RECONNECT_DELAY);
                    return;
                }
                
                const { token, instanceServers } = json.data;
                const endpoint = instanceServers[0].endpoint;
                const ws = new WebSocket(`${endpoint}?token=${token}`);
                wsConnections.kucoin = ws;
                
                ws.onopen = () => {
                    log('kucoin', '‚úÖ Connected');
                    connectionStatus.kucoin = true;
                    updateStatusBar();
                    
                    COINS.forEach((coin, i) => {
                        setTimeout(() => {
                            if (ws.readyState === WebSocket.OPEN) {
                                ws.send(JSON.stringify({
                                    id: Date.now() + i,
                                    type: 'subscribe',
                                    topic: `/market/ticker:${coin.replace('USDT', '-USDT')}`,
                                    privateChannel: false,
                                    response: false
                                }));
                            }
                        }, i * 30);
                    });
                };
                
                ws.onmessage = (e) => {
                    try {
                        const d = JSON.parse(e.data);
                        if (d.type === 'ping') {
                            ws.send(JSON.stringify({ id: d.id, type: 'pong' }));
                            return;
                        }
                        if (d.type === 'message' && d.data) {
                            const symbol = d.topic?.split(':')[1]?.replace('-', '');
                            if (symbol && d.data.bestBid && d.data.bestAsk) {
                                savePrice('kucoin', symbol, parseFloat(d.data.bestBid), parseFloat(d.data.bestAsk));
                            }
                        }
                    } catch (err) {}
                };
                
                ws.onerror = ws.onclose = () => {
                    connectionStatus.kucoin = false;
                    updateStatusBar();
                    setTimeout(initKucoin, CONFIG.RECONNECT_DELAY);
                };
            } catch (err) {
                log('kucoin', '‚ùå Error:', err);
                connectionStatus.kucoin = false;
                updateStatusBar();
                setTimeout(initKucoin, CONFIG.RECONNECT_DELAY);
            }
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // BITGET WebSocket
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        function initBitget() {
            if (wsConnections.bitget?.readyState === WebSocket.OPEN) return;
            
            const ws = new WebSocket('wss://ws.bitget.com/v2/ws/public');
            wsConnections.bitget = ws;
            
            ws.onopen = () => {
                log('bitget', '‚úÖ Connected');
                connectionStatus.bitget = true;
                updateStatusBar();
                ws.send(JSON.stringify({
                    op: 'subscribe',
                    args: COINS.map(c => ({ instType: 'SPOT', channel: 'ticker', instId: c }))
                }));
            };
            
            ws.onmessage = (e) => {
                try {
                    const d = JSON.parse(e.data);
                    if (d.data?.[0]) {
                        const ticker = d.data[0];
                        const symbol = ticker.instId || d.arg?.instId;
                        if (symbol && ticker.bestBid && ticker.bestAsk) {
                            savePrice('bitget', symbol, parseFloat(ticker.bestBid), parseFloat(ticker.bestAsk));
                        }
                    }
                } catch (err) {}
            };
            
            ws.onerror = ws.onclose = () => {
                connectionStatus.bitget = false;
                updateStatusBar();
                setTimeout(initBitget, CONFIG.RECONNECT_DELAY);
            };
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // HUOBI WebSocket
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        function initHuobi() {
            if (wsConnections.huobi?.readyState === WebSocket.OPEN) return;
            
            const ws = new WebSocket('wss://api.huobi.pro/ws');
            wsConnections.huobi = ws;
            
            ws.onopen = () => {
                log('huobi', '‚úÖ Connected');
                connectionStatus.huobi = true;
                updateStatusBar();
                COINS.forEach(coin => {
                    ws.send(JSON.stringify({
                        sub: `market.${coin.toLowerCase()}.bbo`,
                        id: coin
                    }));
                });
            };
            
            ws.onmessage = async (e) => {
                try {
                    let data;
                    if (e.data instanceof Blob) {
                        const arrayBuffer = await e.data.arrayBuffer();
                        const uint8Array = new Uint8Array(arrayBuffer);
                        const text = pako.inflate(uint8Array, { to: 'string' });
                        data = JSON.parse(text);
                    } else {
                        data = JSON.parse(e.data);
                    }
                    
                    if (data.ping) {
                        ws.send(JSON.stringify({ pong: data.ping }));
                        return;
                    }
                    
                    if (data.tick && data.ch) {
                        const symbol = data.ch.replace('market.', '').replace('.bbo', '').toUpperCase();
                        if (data.tick.bid && data.tick.ask) {
                            savePrice('huobi', symbol, parseFloat(data.tick.bid), parseFloat(data.tick.ask));
                        }
                    }
                } catch (err) {}
            };
            
            ws.onerror = ws.onclose = () => {
                connectionStatus.huobi = false;
                updateStatusBar();
                setTimeout(initHuobi, CONFIG.RECONNECT_DELAY);
            };
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // COINBASE WebSocket
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        function initCoinbase() {
            if (wsConnections.coinbase?.readyState === WebSocket.OPEN) return;
            
            const ws = new WebSocket('wss://ws-feed.exchange.coinbase.com');
            wsConnections.coinbase = ws;
            
            ws.onopen = () => {
                log('coinbase', '‚úÖ Connected');
                connectionStatus.coinbase = true;
                updateStatusBar();
                ws.send(JSON.stringify({
                    type: 'subscribe',
                    product_ids: COINS.map(c => c.replace('USDT', '-USDT')),
                    channels: ['ticker']
                }));
            };
            
            ws.onmessage = (e) => {
                try {
                    const d = JSON.parse(e.data);
                    if (d.type === 'ticker' && d.product_id && d.best_bid && d.best_ask) {
                        const symbol = d.product_id.replace('-', '');
                        savePrice('coinbase', symbol, parseFloat(d.best_bid), parseFloat(d.best_ask));
                    }
                } catch (err) {}
            };
            
            ws.onerror = ws.onclose = () => {
                connectionStatus.coinbase = false;
                updateStatusBar();
                setTimeout(initCoinbase, CONFIG.RECONNECT_DELAY);
            };
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // BITFINEX WebSocket
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        function initBitfinex() {
            if (wsConnections.bitfinex?.readyState === WebSocket.OPEN) return;
            
            const ws = new WebSocket('wss://api-pub.bitfinex.com/ws/2');
            wsConnections.bitfinex = ws;
            bitfinexChannels.clear();
            
            ws.onopen = () => {
                log('bitfinex', '‚úÖ Connected');
                connectionStatus.bitfinex = true;
                updateStatusBar();
                COINS.forEach((coin, i) => {
                    setTimeout(() => {
                        if (ws.readyState === WebSocket.OPEN) {
                            ws.send(JSON.stringify({
                                event: 'subscribe',
                                channel: 'ticker',
                                symbol: `t${coin}`
                            }));
                        }
                    }, i * 50);
                });
            };
            
            ws.onmessage = (e) => {
                try {
                    const d = JSON.parse(e.data);
                    
                    if (d.event === 'subscribed' && d.chanId && d.symbol) {
                        bitfinexChannels.set(d.chanId, d.symbol.replace('t', ''));
                        return;
                    }
                    
                    if (Array.isArray(d) && d.length >= 2 && Array.isArray(d[1]) && d[1].length >= 4) {
                        const symbol = bitfinexChannels.get(d[0]);
                        if (symbol) {
                            savePrice('bitfinex', symbol, parseFloat(d[1][0]), parseFloat(d[1][2]));
                        }
                    }
                } catch (err) {}
            };
            
            ws.onerror = ws.onclose = () => {
                connectionStatus.bitfinex = false;
                updateStatusBar();
                setTimeout(initBitfinex, CONFIG.RECONNECT_DELAY);
            };
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // BINGX WebSocket
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        function initBingx() {
            if (wsConnections.bingx?.readyState === WebSocket.OPEN) return;
            
            const ws = new WebSocket('wss://open-api-ws.bingx.com/market');
            wsConnections.bingx = ws;
            
            ws.onopen = () => {
                log('bingx', '‚úÖ Connected');
                connectionStatus.bingx = true;
                updateStatusBar();
                COINS.forEach((coin, i) => {
                    setTimeout(() => {
                        if (ws.readyState === WebSocket.OPEN) {
                            const symbol = coin.replace('USDT', '-USDT');
                            ws.send(JSON.stringify({
                                id: Date.now().toString(),
                                reqType: 'sub',
                                dataType: `${symbol}@bookTicker`
                            }));
                        }
                    }, i * 30);
                });
            };
            
            ws.onmessage = async (e) => {
                try {
                    let data;
                    if (e.data instanceof Blob) {
                        const arrayBuffer = await e.data.arrayBuffer();
                        const uint8Array = new Uint8Array(arrayBuffer);
                        try {
                            const text = pako.inflate(uint8Array, { to: 'string' });
                            data = JSON.parse(text);
                        } catch {
                            const text = new TextDecoder().decode(uint8Array);
                            data = JSON.parse(text);
                        }
                    } else {
                        data = JSON.parse(e.data);
                    }
                    
                    if (data.ping) {
                        ws.send(JSON.stringify({ pong: data.ping }));
                        return;
                    }
                    
                    if (data.data) {
                        const d = data.data;
                        const symbol = (d.s || d.symbol || '').replace('-', '');
                        if (symbol && d.b && d.a) {
                            savePrice('bingx', symbol, parseFloat(d.b), parseFloat(d.a));
                        } else if (symbol && d.bidPrice && d.askPrice) {
                            savePrice('bingx', symbol, parseFloat(d.bidPrice), parseFloat(d.askPrice));
                        }
                    }
                } catch (err) {}
            };
            
            ws.onerror = ws.onclose = () => {
                connectionStatus.bingx = false;
                updateStatusBar();
                setTimeout(initBingx, CONFIG.RECONNECT_DELAY);
            };
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // UI
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        function updateStatusBar() {
            const connected = Object.values(connectionStatus).filter(Boolean).length;
            const total = Object.keys(connectionStatus).length;
            
            let className = 'disconnected';
            let text = `‚ùå –ù–µ—Ç –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–π`;
            
            if (connected === total) {
                className = 'connected';
                text = `‚úÖ –í—Å–µ ${total} –±–∏—Ä–∂ –ø–æ–¥–∫–ª—é—á–µ–Ω—ã`;
            } else if (connected > 0) {
                className = 'connecting';
                text = `‚è≥ –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ: ${connected}/${total} –±–∏—Ä–∂`;
            }
            
            statusBar.className = `status-bar ${className}`;
            statusBar.textContent = text;
        }

        function scheduleUpdate() {
            const now = Date.now();
            if (now - lastUpdate < CONFIG.UPDATE_THROTTLE) {
                if (updateTimer) clearTimeout(updateTimer);
                updateTimer = setTimeout(() => {
                    lastUpdate = Date.now();
                    render();
                }, CONFIG.UPDATE_THROTTLE);
                return;
            }
            lastUpdate = now;
            if (updateTimer) clearTimeout(updateTimer);
            render();
        }

        function render() {
            const results = [];
            const exchangeIds = Object.keys(FEES);
            
            for (const coin of COINS) {
                const exchangeData = exchangeIds
                    .map(id => ({
                        id,
                        name: EXCHANGE_NAMES[id],
                        fee: FEES[id],
                        data: prices[id][coin]
                    }))
                    .filter(e => e.data?.bid > 0 && e.data?.ask > 0);
                
                if (exchangeData.length < 2) continue;
                
                let best = { profit: -Infinity, scenario: null, buyEx: null, sellEx: null };
                
                for (const buyEx of exchangeData) {
                    for (const sellEx of exchangeData) {
                        if (buyEx.id === sellEx.id) continue;
                        
                        const profit = calculateProfit(
                            buyEx.data.ask, buyEx.fee,
                            sellEx.data.bid, sellEx.fee,
                            CONFIG.TRADE_AMOUNT
                        );
                        
                        if (profit > best.profit) {
                            best = {
                                profit,
                                scenario: {
                                    buyExchange: buyEx.name,
                                    sellExchange: sellEx.name,
                                },
                                buyEx,
                                sellEx
                            };
                        }
                    }
                }
                
                if (best.scenario) {
                    // –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –¥–ª—è –ª—É—á—à–µ–≥–æ —Å—Ü–µ–Ω–∞—Ä–∏—è
                    const recs = calculateRecommendations(
                        best.buyEx.data.ask, best.buyEx.fee,
                        best.sellEx.data.bid, best.sellEx.fee
                    );
                    
                    results.push({
                        coin,
                        profit: best.profit,
                        scenario: best.scenario,
                        exchanges: exchangeData,
                        recommendations: recs,
                        buyPrice: best.buyEx.data.ask,
                        sellPrice: best.sellEx.data.bid,
                    });
                }
            }
            
            results.sort((a, b) => b.profit - a.profit);
            const topResults = results.slice(0, CONFIG.TOP_RESULTS);
            
            if (topResults.length === 0) {
                const totalPrices = Object.values(prices).reduce((sum, p) => sum + Object.keys(p).length, 0);
                contentDiv.innerHTML = `
                    <div class="loading">
                        ${totalPrices === 0 
                            ? '‚è≥ –û–∂–∏–¥–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö —Å –±–∏—Ä–∂...' 
                            : '‚ö†Ô∏è –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —Ä–∞—Å—á–µ—Ç–∞'}
                        <br><br>–ü–æ–ª—É—á–µ–Ω–æ —Ü–µ–Ω: ${totalPrices}
                    </div>
                `;
                return;
            }
            
            const positiveCount = topResults.filter(r => r.profit >= 0).length;
            
            let html = `
                <div class="summary">üèÜ –¢–û–ü-${topResults.length} –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–µ–π | ${positiveCount} —Å –ø—Ä–∏–±—ã–ª—å—é</div>
                <div class="arbitrage-list">
            `;
            
            for (const result of topResults) {
                const isPositive = result.profit >= 0;
                const profitText = isPositive ? `+${formatPrice(result.profit)}` : formatPrice(result.profit);
                const recs = result.recommendations;
                
                let exchangesHtml = '';
                for (const ex of result.exchanges) {
                    exchangesHtml += `
                        <div class="exchange-row">
                            <span class="exchange-name">${ex.name}:</span>
                            <span class="exchange-prices">
                                –ü–æ–∫—É–ø–∫–∞ ${formatPrice(ex.data.ask)} | –ü—Ä–æ–¥–∞–∂–∞ ${formatPrice(ex.data.bid)}
                            </span>
                        </div>
                    `;
                }
                
                // –§–æ—Ä–º–∏—Ä—É–µ–º —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –ø–æ —Å—É–º–º–∞–º
                let recsHtml = '';
                const showAmounts = [100, 500, 1000, 2500];
                for (const amount of showAmounts) {
                    const rec = recs.recommendations.find(r => r.amount === amount);
                    if (rec) {
                        const isOptimal = amount === recs.optimalAmount;
                        const profitClass = rec.profit >= 0 ? 'positive' : 'negative';
                        const profitSign = rec.profit >= 0 ? '+' : '';
                        recsHtml += `
                            <div class="rec-item">
                                <span class="rec-amount">${amount} USDT${isOptimal ? '<span class="optimal-badge">‚≠ê –û–ø—Ç–∏–º–∞–ª—å–Ω–æ</span>' : ''}</span>
                                <span class="rec-profit ${profitClass}">${profitSign}${formatPrice(rec.profit)} USDT</span>
                            </div>
                        `;
                    }
                }
                
                // –≠—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—å –∏ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è
                const effClass = recs.efficiency >= 0 ? 'positive' : 'negative';
                const effSign = recs.efficiency >= 0 ? '+' : '';
                
                html += `
                    <div class="arbitrage-card ${isPositive ? 'positive' : 'negative'}">
                        <div class="card-header">
                            <span class="coin-symbol">${result.coin.replace('USDT', '/USDT')}</span>
                            <span class="profit-badge ${isPositive ? 'positive' : 'negative'}">${profitText} USDT</span>
                        </div>
                        <div class="exchanges-grid">${exchangesHtml}</div>
                        <div class="scenario">
                            üí° ${result.scenario.buyExchange} ‚Üí ${result.scenario.sellExchange}
                        </div>
                        
                        <div class="recommendation">
                            <div class="recommendation-title">
                                üìä –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –ø–æ —Å—É–º–º–µ
                            </div>
                            <div class="efficiency">
                                <div class="efficiency-value ${effClass}">${effSign}${recs.efficiency.toFixed(3)}%</div>
                                <div class="efficiency-label">–≠—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—å (ROI –Ω–∞ –ª—é–±—É—é —Å—É–º–º—É)</div>
                            </div>
                            <div class="recommendation-grid" style="margin-top: 10px;">
                                ${recsHtml}
                            </div>
                            ${recs.isProfitable ? `
                                <div style="margin-top: 10px; font-size: 12px; color: var(--positive-color);">
                                    ‚úÖ –†–µ–∫–æ–º–µ–Ω–¥—É–µ–º–∞—è —Å—É–º–º–∞: <strong>${recs.optimalAmount} USDT</strong>
                                    (–ø—Ä–∏–±—ã–ª—å ~${formatPrice(recs.recommendations.find(r => r.amount === recs.optimalAmount)?.profit || 0)} USDT)
                                </div>
                            ` : `
                                <div style="margin-top: 10px; font-size: 12px; color: var(--negative-color);">
                                    ‚ö†Ô∏è –ê—Ä–±–∏—Ç—Ä–∞–∂ —É–±—ã—Ç–æ—á–Ω—ã–π –ø—Ä–∏ –ª—é–±–æ–π —Å—É–º–º–µ
                                </div>
                            `}
                        </div>
                    </div>
                `;
            }
            
            html += '</div>';
            contentDiv.innerHTML = html;
        }

        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        function initAll() {
            console.log('üöÄ –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∞—Ä–±–∏—Ç—Ä–∞–∂–Ω–æ–≥–æ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è...');
            console.log(`üìä –ú–æ–Ω–µ—Ç: ${COINS.length}, –ë–∏—Ä–∂: ${Object.keys(FEES).length}`);
            
            updateStatusBar();
            
            initBinance();
            initBybit();
            initOkx();
            initKucoin();
            initBitget();
            initHuobi();
            initCoinbase();
            initBitfinex();
            initBingx();
        }

        function closeAll() {
            Object.values(wsConnections).forEach(ws => {
                if (ws) ws.close();
            });
        }

        refreshBtn.onclick = () => {
            console.log('üîÑ –ü–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ...');
            closeAll();
            
            Object.keys(prices).forEach(k => prices[k] = {});
            Object.keys(connectionStatus).forEach(k => connectionStatus[k] = false);
            bitfinexChannels.clear();
            
            contentDiv.innerHTML = '<div class="loading">‚è≥ –ü–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –±–∏—Ä–∂–∞–º...</div>';
            updateStatusBar();
            
            setTimeout(initAll, 1000);
        };

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initAll);
        } else {
            initAll();
        }
    </script>
</body>
</html>
