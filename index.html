<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–ê—Ä–±–∏—Ç—Ä–∞–∂ –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
    <style>
        :root {
            --bg-color: var(--tg-theme-bg-color, #ffffff);
            --text-color: var(--tg-theme-text-color, #000000);
            --hint-color: var(--tg-theme-hint-color, #999999);
            --button-color: var(--tg-theme-button-color, #3390ec);
            --button-text-color: var(--tg-theme-button-text-color, #ffffff);
            --secondary-bg: var(--tg-theme-secondary-bg-color, #f0f0f0);
            --positive-color: #4caf50;
            --negative-color: #ff4444;
            --warning-color: #ff9800;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-color);
            color: var(--text-color);
            padding: 16px;
            min-height: 100vh;
        }
        .container { max-width: 600px; margin: 0 auto; }
        h1 { font-size: 22px; margin-bottom: 16px; text-align: center; }
        .status-bar {
            text-align: center;
            padding: 10px 16px;
            margin-bottom: 12px;
            border-radius: 10px;
            font-size: 13px;
            font-weight: 500;
        }
        .status-bar.connected { background: var(--positive-color); color: white; }
        .status-bar.connecting { background: var(--warning-color); color: white; }
        .status-bar.disconnected { background: var(--negative-color); color: white; }
        .loading {
            text-align: center;
            padding: 40px 20px;
            color: var(--hint-color);
            font-size: 14px;
            line-height: 1.6;
        }
        .arbitrage-list { display: flex; flex-direction: column; gap: 12px; }
        .arbitrage-card {
            background: var(--secondary-bg);
            border-radius: 12px;
            padding: 14px 16px;
            border-left: 4px solid var(--button-color);
        }
        .arbitrage-card.positive { border-left-color: var(--positive-color); }
        .arbitrage-card.negative { border-left-color: var(--negative-color); }
        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        .coin-symbol { font-size: 17px; font-weight: 600; }
        .profit-badge {
            font-size: 16px;
            font-weight: 700;
            padding: 6px 12px;
            border-radius: 8px;
            color: white;
        }
        .profit-badge.positive { background: var(--positive-color); }
        .profit-badge.negative { background: var(--negative-color); }
        .exchanges-grid { display: flex; flex-direction: column; gap: 6px; font-size: 13px; }
        .exchange-row { display: flex; justify-content: space-between; align-items: center; }
        .exchange-name { color: var(--hint-color); }
        .exchange-prices { font-weight: 500; }
        .scenario {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid rgba(128, 128, 128, 0.2);
            font-size: 13px;
            color: var(--hint-color);
        }
        .summary {
            text-align: center;
            padding: 10px;
            margin-bottom: 12px;
            font-size: 14px;
            font-weight: 500;
            color: var(--hint-color);
        }
        .recommendation {
            margin-top: 12px;
            padding: 12px;
            background: rgba(128, 128, 128, 0.1);
            border-radius: 8px;
        }
        .recommendation-title {
            font-size: 13px;
            font-weight: 600;
            margin-bottom: 10px;
        }
        .efficiency {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }
        .efficiency-value {
            font-size: 16px;
            font-weight: 700;
        }
        .efficiency-value.positive { color: var(--positive-color); }
        .efficiency-value.negative { color: var(--negative-color); }
        .efficiency-label {
            font-size: 12px;
            color: var(--hint-color);
        }
        .recommendation-grid {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        .rec-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 8px;
            background: rgba(128, 128, 128, 0.1);
            border-radius: 6px;
            font-size: 12px;
        }
        .rec-amount { font-weight: 500; }
        .rec-profit.positive { color: var(--positive-color); }
        .rec-profit.negative { color: var(--negative-color); }
        .optimal-badge {
            margin-left: 6px;
            font-size: 10px;
            color: var(--positive-color);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üìà –ê—Ä–±–∏—Ç—Ä–∞–∂ –∫—Ä–∏–ø—Ç–æ–≤–∞–ª—é—Ç</h1>
        <div id="statusBar" class="status-bar disconnected">‚è≥ –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ...</div>
        <button id="refreshBtn" style="width:100%;padding:12px;margin-bottom:12px;border:none;border-radius:10px;background:var(--button-color);color:var(--button-text-color);font-size:14px;font-weight:500;cursor:pointer;">üîÑ –ü–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–∏—Ç—å</button>
        <div id="content" class="arbitrage-list">
            <div class="loading">‚è≥ –ó–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö...</div>
        </div>
    </div>

    <script>
        'use strict';
        
        const CONFIG = {
            TRADE_AMOUNT: 100,
            UPDATE_THROTTLE: 500,
            RECONNECT_DELAY: 5000,
            TOP_RESULTS: 10,
            AMOUNTS: [50, 100, 250, 500, 1000, 2500, 5000],
        };

        const COINS = [
            'BTCUSDT', 'ETHUSDT', 'BNBUSDT', 'XRPUSDT', 'SOLUSDT', 
            'TRXUSDT', 'DOGEUSDT', 'ADAUSDT', 'LINKUSDT', 'LTCUSDT', 
            'AVAXUSDT', 'XLMUSDT', 'XMRUSDT', 'BCHUSDT', 'DOTUSDT',
            'UNIUSDT', 'SHIBUSDT', 'ATOMUSDT', 'NEARUSDT', 'AAVEUSDT',
            'APTUSDT', 'ARBUSDT', 'OPUSDT', 'FILUSDT', 'ICPUSDT',
            'ETCUSDT', 'ALGOUSDT', 'VETUSDT', 'MATICUSDT', 'INJUSDT',
            'FTMUSDT', 'AXSUSDT', 'SUIUSDT', 'SEIUSDT', 'TONUSDT',
            'PEPEUSDT', 'MKRUSDT', 'STXUSDT', 'CRVUSDT', 'LDOUSDT'
        ];

        const FEES = {
            binance: 0.001,
            bybit: 0.001,
            okx: 0.001,
            kucoin: 0.001,
            bitget: 0.001,
            huobi: 0.002,
            coinbase: 0.006,
            bitfinex: 0.002,
            bingx: 0.001,
            kraken: 0.0026,
            gateio: 0.002,
            poloniex: 0.002,
            bitstamp: 0.005,
            gemini: 0.004,
        };

        const EXCHANGE_NAMES = {
            binance: 'Binance',
            bybit: 'Bybit',
            okx: 'OKX',
            kucoin: 'KuCoin',
            bitget: 'Bitget',
            huobi: 'Huobi',
            coinbase: 'Coinbase',
            bitfinex: 'Bitfinex',
            bingx: 'BingX',
            kraken: 'Kraken',
            gateio: 'Gate.io',
            poloniex: 'Poloniex',
            bitstamp: 'Bitstamp',
            gemini: 'Gemini',
        };

        const prices = {};
        const wsConnections = {};
        const connectionStatus = {};
        const bitfinexChannels = new Map();
        
        Object.keys(FEES).forEach(ex => {
            prices[ex] = {};
            connectionStatus[ex] = false;
        });

        let lastUpdate = 0;
        let updateTimer = null;

        const contentDiv = document.getElementById('content');
        const statusBar = document.getElementById('statusBar');
        const refreshBtn = document.getElementById('refreshBtn');

        const tg = window.Telegram?.WebApp;
        if (tg) { tg.ready(); tg.expand(); }

        function log(exchange, msg, data = '') {
            console.log(`[${exchange.toUpperCase()}] ${msg}`, data);
        }

        function formatPrice(num) {
            if (!Number.isFinite(num)) return 'N/A';
            return num.toFixed(2);
        }

        function savePrice(exchange, symbol, bid, ask) {
            if (bid > 0 && ask > 0 && COINS.includes(symbol)) {
                prices[exchange][symbol] = { bid, ask, timestamp: Date.now() };
                scheduleUpdate();
            }
        }

        function calculateProfit(buyPrice, buyFee, sellPrice, sellFee, amount) {
            if (!buyPrice || !sellPrice || buyPrice <= 0 || sellPrice <= 0) return -Infinity;
            const afterBuyFee = amount * (1 - buyFee);
            const crypto = afterBuyFee / buyPrice;
            const gross = crypto * sellPrice;
            const net = gross * (1 - sellFee);
            return net - amount;
        }

        function calculateEfficiency(buyPrice, buyFee, sellPrice, sellFee) {
            const ratio = (sellPrice / buyPrice) * (1 - buyFee) * (1 - sellFee);
            return (ratio - 1) * 100;
        }

        function calculateMinAmount(buyPrice, buyFee, sellPrice, sellFee, minFee = 0) {
            const efficiency = calculateEfficiency(buyPrice, buyFee, sellPrice, sellFee);
            if (efficiency <= 0) return Infinity;
            return minFee > 0 ? (minFee * 100 / efficiency) : 0;
        }

        function estimateLiquidity(coin, price) {
            
            const highLiquidityCoins = ['BTCUSDT', 'ETHUSDT', 'BNBUSDT', 'XRPUSDT', 'SOLUSDT'];
            const mediumLiquidityCoins = ['ADAUSDT', 'DOTUSDT', 'AVAXUSDT', 'LINKUSDT', 'UNIUSDT', 'ATOMUSDT'];
            
            if (highLiquidityCoins.includes(coin)) {
                return price > 1000 ? 50000 : 25000;
            } else if (mediumLiquidityCoins.includes(coin)) {
                return price > 10 ? 20000 : 10000;
            } else {
                return price > 1 ? 5000 : 2000;
            }
        }

        function calculateWeightedPrice(basePrice, amount, liquidity) {
            if (amount < liquidity * 0.1) {
                return basePrice;
            }
            
            const utilization = Math.min(amount / liquidity, 1);
            const slippage = utilization * utilization * 0.005;
            
            return basePrice * (1 + slippage);
        }

        function calculateOptimalEntryAmount(coin, buyPrice, sellPrice, buyFee, sellFee, maxSlippage = 0.1) {
            const liquidity = estimateLiquidity(coin, buyPrice);
            const efficiency = calculateEfficiency(buyPrice, buyFee, sellPrice, sellFee);
            
            if (efficiency <= 0) return { optimalAmount: 0, reason: '–ê—Ä–±–∏—Ç—Ä–∞–∂ —É–±—ã—Ç–æ—á–µ–Ω' };
            
            let optimalAmount = 0;
            let maxProfit = -Infinity;
            
            const testAmounts = [100, 250, 500, 1000, 2500, 5000, 10000];
            
            for (const amount of testAmounts) {
                if (amount > liquidity * 2) break;
                
                const actualBuyPrice = calculateWeightedPrice(buyPrice, amount, liquidity);
                const actualSellPrice = calculateWeightedPrice(sellPrice, amount, liquidity);
                
                const buySlippage = ((actualBuyPrice - buyPrice) / buyPrice) * 100;
                const sellSlippage = ((sellPrice - actualSellPrice) / sellPrice) * 100;
                const totalSlippage = buySlippage + sellSlippage;
                
                if (totalSlippage > maxSlippage) {
                    break;
                }
                
                const profit = calculateProfit(actualBuyPrice, buyFee, actualSellPrice, sellFee, amount);
                
                if (profit > maxProfit) {
                    maxProfit = profit;
                    optimalAmount = amount;
                }
            }
            
            return {
                optimalAmount,
                maxProfit,
                liquidity,
                reason: optimalAmount > 0 ? '–û–ø—Ç–∏–º–∞–ª—å–Ω–∞—è —Å—É–º–º–∞ –Ω–∞–π–¥–µ–Ω–∞' : '–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–∞—è –ª–∏–∫–≤–∏–¥–Ω–æ—Å—Ç—å'
            };
        }

        function calculateRecommendations(coin, buyPrice, buyFee, sellPrice, sellFee) {
            const efficiency = calculateEfficiency(buyPrice, buyFee, sellPrice, sellFee);
            const isProfitable = efficiency > 0;
            
            const optimalEntry = calculateOptimalEntryAmount(coin, buyPrice, sellPrice, buyFee, sellFee);
            
            const recommendations = CONFIG.AMOUNTS.map(amount => {
                const liquidity = estimateLiquidity(coin, buyPrice);
                const actualBuyPrice = calculateWeightedPrice(buyPrice, amount, liquidity);
                const actualSellPrice = calculateWeightedPrice(sellPrice, amount, liquidity);
                
                const profit = calculateProfit(actualBuyPrice, buyFee, actualSellPrice, sellFee, amount);
                const buySlippage = ((actualBuyPrice - buyPrice) / buyPrice) * 100;
                const sellSlippage = ((sellPrice - actualSellPrice) / sellPrice) * 100;
                
                return {
                    amount,
                    profit,
                    roi: efficiency,
                    slippage: buySlippage + sellSlippage,
                    actualBuyPrice,
                    actualSellPrice
                };
            });
            
            return {
                efficiency,
                isProfitable,
                optimalAmount: optimalEntry.optimalAmount || (isProfitable ? 500 : 0),
                maxProfit: optimalEntry.maxProfit,
                liquidity: optimalEntry.liquidity,
                recommendations
            };
        }

        
        function initBinance() {
            if (wsConnections.binance?.readyState === WebSocket.OPEN) return;
            
            const ws = new WebSocket('wss://stream.binance.com:9443/ws/!bookTicker');
            wsConnections.binance = ws;
            
            ws.onopen = () => {
                log('binance', '‚úÖ Connected');
                connectionStatus.binance = true;
                updateStatusBar();
            };
            
            ws.onmessage = (e) => {
                try {
                    const d = JSON.parse(e.data);
                    if (d.s && d.b && d.a) {
                        savePrice('binance', d.s, parseFloat(d.b), parseFloat(d.a));
                    }
                } catch (err) {}
            };
            
            ws.onerror = ws.onclose = () => {
                connectionStatus.binance = false;
                updateStatusBar();
                setTimeout(initBinance, CONFIG.RECONNECT_DELAY);
            };
        }

        
        function initBybit() {
            if (wsConnections.bybit?.readyState === WebSocket.OPEN) return;
            
            const ws = new WebSocket('wss://stream.bybit.com/v5/public/spot');
            wsConnections.bybit = ws;
            
            ws.onopen = () => {
                log('bybit', '‚úÖ Connected');
                connectionStatus.bybit = true;
                updateStatusBar();
                ws.send(JSON.stringify({
                    op: 'subscribe',
                    args: COINS.map(c => `orderbook.1.${c}`)
                }));
            };
            
            ws.onmessage = (e) => {
                try {
                    const d = JSON.parse(e.data);
                    if (d.topic?.startsWith('orderbook.1.')) {
                        const symbol = d.topic.replace('orderbook.1.', '');
                        if (d.data?.b?.[0] && d.data?.a?.[0]) {
                            savePrice('bybit', symbol, parseFloat(d.data.b[0][0]), parseFloat(d.data.a[0][0]));
                        }
                    }
                } catch (err) {}
            };
            
            ws.onerror = ws.onclose = () => {
                connectionStatus.bybit = false;
                updateStatusBar();
                setTimeout(initBybit, CONFIG.RECONNECT_DELAY);
            };
        }

        
        function initOkx() {
            if (wsConnections.okx?.readyState === WebSocket.OPEN) return;
            
            const ws = new WebSocket('wss://ws.okx.com:8443/ws/v5/public');
            wsConnections.okx = ws;
            
            ws.onopen = () => {
                log('okx', '‚úÖ Connected');
                connectionStatus.okx = true;
                updateStatusBar();
                ws.send(JSON.stringify({
                    op: 'subscribe',
                    args: COINS.map(c => ({ channel: 'tickers', instId: c.replace('USDT', '-USDT') }))
                }));
            };
            
            ws.onmessage = (e) => {
                try {
                    const d = JSON.parse(e.data);
                    if (d.data?.[0]?.instId) {
                        const symbol = d.data[0].instId.replace('-', '');
                        savePrice('okx', symbol, parseFloat(d.data[0].bidPx), parseFloat(d.data[0].askPx));
                    }
                } catch (err) {}
            };
            
            ws.onerror = ws.onclose = () => {
                connectionStatus.okx = false;
                updateStatusBar();
                setTimeout(initOkx, CONFIG.RECONNECT_DELAY);
            };
        }

        
        async function initKucoin() {
            if (wsConnections.kucoin?.readyState === WebSocket.OPEN) return;
            
            try {
                const resp = await fetch('https://api.kucoin.com/api/v1/bullet-public', { method: 'POST' });
                const json = await resp.json();
                
                if (json.code !== '200000' || !json.data?.token) {
                    log('kucoin', '‚ùå Failed to get token');
                    connectionStatus.kucoin = false;
                    updateStatusBar();
                    setTimeout(initKucoin, CONFIG.RECONNECT_DELAY);
                    return;
                }
                
                const { token, instanceServers } = json.data;
                const endpoint = instanceServers[0].endpoint;
                const ws = new WebSocket(`${endpoint}?token=${token}`);
                wsConnections.kucoin = ws;
                
                ws.onopen = () => {
                    log('kucoin', '‚úÖ Connected');
                    connectionStatus.kucoin = true;
                    updateStatusBar();
                    
                    COINS.forEach((coin, i) => {
                        setTimeout(() => {
                            if (ws.readyState === WebSocket.OPEN) {
                                ws.send(JSON.stringify({
                                    id: Date.now() + i,
                                    type: 'subscribe',
                                    topic: `/market/ticker:${coin.replace('USDT', '-USDT')}`,
                                    privateChannel: false,
                                    response: false
                                }));
                            }
                        }, i * 30);
                    });
                };
                
                ws.onmessage = (e) => {
                    try {
                        const d = JSON.parse(e.data);
                        if (d.type === 'ping') {
                            ws.send(JSON.stringify({ id: d.id, type: 'pong' }));
                            return;
                        }
                        if (d.type === 'message' && d.data) {
                            const symbol = d.topic?.split(':')[1]?.replace('-', '');
                            if (symbol && d.data.bestBid && d.data.bestAsk) {
                                savePrice('kucoin', symbol, parseFloat(d.data.bestBid), parseFloat(d.data.bestAsk));
                            }
                        }
                    } catch (err) {}
                };
                
                ws.onerror = ws.onclose = () => {
                    connectionStatus.kucoin = false;
                    updateStatusBar();
                    setTimeout(initKucoin, CONFIG.RECONNECT_DELAY);
                };
            } catch (err) {
                log('kucoin', '‚ùå Error:', err);
                connectionStatus.kucoin = false;
                updateStatusBar();
                setTimeout(initKucoin, CONFIG.RECONNECT_DELAY);
            }
        }

        
        function initBitget() {
            if (wsConnections.bitget?.readyState === WebSocket.OPEN) return;
            
            const ws = new WebSocket('wss://ws.bitget.com/v2/ws/public');
            wsConnections.bitget = ws;
            
            ws.onopen = () => {
                log('bitget', '‚úÖ Connected');
                connectionStatus.bitget = true;
                updateStatusBar();
                ws.send(JSON.stringify({
                    op: 'subscribe',
                    args: COINS.map(c => ({ instType: 'SPOT', channel: 'books1', instId: c }))
                }));
            };
            
            ws.onmessage = (e) => {
                try {
                    const d = JSON.parse(e.data);
                    if (d.data?.[0]) {
                        const ticker = d.data[0];
                        const symbol = ticker.instId || d.arg?.instId;
                        const bid = ticker.bids?.[0]?.[0] || ticker.bidPr;
                        const ask = ticker.asks?.[0]?.[0] || ticker.askPr;
                        if (symbol && bid && ask) {
                            savePrice('bitget', symbol, parseFloat(bid), parseFloat(ask));
                        }
                    }
                } catch (err) {}
            };
            
            ws.onerror = ws.onclose = () => {
                connectionStatus.bitget = false;
                updateStatusBar();
                setTimeout(initBitget, CONFIG.RECONNECT_DELAY);
            };
        }

        
        function initHuobi() {
            if (wsConnections.huobi?.readyState === WebSocket.OPEN) return;
            
            const ws = new WebSocket('wss://api.huobi.pro/ws');
            wsConnections.huobi = ws;
            
            ws.onopen = () => {
                log('huobi', '‚úÖ Connected');
                connectionStatus.huobi = true;
                updateStatusBar();
                COINS.forEach(coin => {
                    ws.send(JSON.stringify({
                        sub: `market.${coin.toLowerCase()}.bbo`,
                        id: coin
                    }));
                });
            };
            
            ws.onmessage = async (e) => {
                try {
                    let data;
                    if (e.data instanceof Blob) {
                        const arrayBuffer = await e.data.arrayBuffer();
                        const uint8Array = new Uint8Array(arrayBuffer);
                        const text = pako.inflate(uint8Array, { to: 'string' });
                        data = JSON.parse(text);
                    } else {
                        data = JSON.parse(e.data);
                    }
                    
                    if (data.ping) {
                        ws.send(JSON.stringify({ pong: data.ping }));
                        return;
                    }
                    
                    if (data.tick && data.ch) {
                        const symbol = data.ch.replace('market.', '').replace('.bbo', '').toUpperCase();
                        if (data.tick.bid && data.tick.ask) {
                            savePrice('huobi', symbol, parseFloat(data.tick.bid), parseFloat(data.tick.ask));
                        }
                    }
                } catch (err) {}
            };
            
            ws.onerror = ws.onclose = () => {
                connectionStatus.huobi = false;
                updateStatusBar();
                setTimeout(initHuobi, CONFIG.RECONNECT_DELAY);
            };
        }

        
        function initCoinbase() {
            if (wsConnections.coinbase?.readyState === WebSocket.OPEN) return;
            
            const ws = new WebSocket('wss://ws-feed.exchange.coinbase.com');
            wsConnections.coinbase = ws;
            
            ws.onopen = () => {
                log('coinbase', '‚úÖ Connected');
                connectionStatus.coinbase = true;
                updateStatusBar();
                ws.send(JSON.stringify({
                    type: 'subscribe',
                    product_ids: COINS.map(c => c.replace('USDT', '-USDT')),
                    channels: ['ticker']
                }));
            };
            
            ws.onmessage = (e) => {
                try {
                    const d = JSON.parse(e.data);
                    if (d.type === 'ticker' && d.product_id && d.best_bid && d.best_ask) {
                        const symbol = d.product_id.replace('-', '');
                        savePrice('coinbase', symbol, parseFloat(d.best_bid), parseFloat(d.best_ask));
                    }
                } catch (err) {}
            };
            
            ws.onerror = ws.onclose = () => {
                connectionStatus.coinbase = false;
                updateStatusBar();
                setTimeout(initCoinbase, CONFIG.RECONNECT_DELAY);
            };
        }

        
        function initBitfinex() {
            if (wsConnections.bitfinex?.readyState === WebSocket.OPEN) return;
            
            const ws = new WebSocket('wss://api-pub.bitfinex.com/ws/2');
            wsConnections.bitfinex = ws;
            bitfinexChannels.clear();
            
            ws.onopen = () => {
                log('bitfinex', '‚úÖ Connected');
                connectionStatus.bitfinex = true;
                updateStatusBar();
                COINS.forEach((coin, i) => {
                    setTimeout(() => {
                        if (ws.readyState === WebSocket.OPEN) {
                            const base = coin.replace('USDT', '');
                            ws.send(JSON.stringify({
                                event: 'subscribe',
                                channel: 'ticker',
                                symbol: `t${base}:USDT`
                            }));
                        }
                    }, i * 50);
                });
            };
            
            ws.onmessage = (e) => {
                try {
                    const d = JSON.parse(e.data);
                    
                    if (d.event === 'subscribed' && d.chanId && d.symbol) {
                        const symbol = d.symbol.replace('t', '').replace(':', '') + 'USDT';
                        bitfinexChannels.set(d.chanId, symbol.replace('USDTUSDT', 'USDT'));
                        return;
                    }
                    
                    if (Array.isArray(d) && d.length >= 2 && Array.isArray(d[1]) && d[1].length >= 4) {
                        const symbol = bitfinexChannels.get(d[0]);
                        if (symbol) {
                            savePrice('bitfinex', symbol, parseFloat(d[1][0]), parseFloat(d[1][2]));
                        }
                    }
                } catch (err) {}
            };
            
            ws.onerror = ws.onclose = () => {
                connectionStatus.bitfinex = false;
                updateStatusBar();
                setTimeout(initBitfinex, CONFIG.RECONNECT_DELAY);
            };
        }

        
        function initBingx() {
            if (wsConnections.bingx?.readyState === WebSocket.OPEN) return;
            
            const ws = new WebSocket('wss://open-api-ws.bingx.com/market');
            wsConnections.bingx = ws;
            
            ws.onopen = () => {
                log('bingx', '‚úÖ Connected');
                connectionStatus.bingx = true;
                updateStatusBar();
                COINS.forEach((coin, i) => {
                    setTimeout(() => {
                        if (ws.readyState === WebSocket.OPEN) {
                            const symbol = coin.replace('USDT', '-USDT');
                            ws.send(JSON.stringify({
                                id: Date.now().toString(),
                                reqType: 'sub',
                                dataType: `${symbol}@bookTicker`
                            }));
                        }
                    }, i * 30);
                });
            };
            
            ws.onmessage = async (e) => {
                try {
                    let data;
                    if (e.data instanceof Blob) {
                        const arrayBuffer = await e.data.arrayBuffer();
                        const uint8Array = new Uint8Array(arrayBuffer);
                        try {
                            const text = pako.inflate(uint8Array, { to: 'string' });
                            data = JSON.parse(text);
                        } catch {
                            const text = new TextDecoder().decode(uint8Array);
                            data = JSON.parse(text);
                        }
                    } else {
                        data = JSON.parse(e.data);
                    }
                    
                    if (data.ping) {
                        ws.send(JSON.stringify({ pong: data.ping }));
                        return;
                    }
                    
                    if (data.data) {
                        const d = data.data;
                        const symbol = (d.s || d.symbol || '').replace('-', '');
                        if (symbol && d.b && d.a) {
                            savePrice('bingx', symbol, parseFloat(d.b), parseFloat(d.a));
                        } else if (symbol && d.bidPrice && d.askPrice) {
                            savePrice('bingx', symbol, parseFloat(d.bidPrice), parseFloat(d.askPrice));
                        }
                    }
                } catch (err) {}
            };
            
            ws.onerror = ws.onclose = () => {
                connectionStatus.bingx = false;
                updateStatusBar();
                setTimeout(initBingx, CONFIG.RECONNECT_DELAY);
            };
        }

        
        function initKraken() {
            if (wsConnections.kraken?.readyState === WebSocket.OPEN) return;
            
            const ws = new WebSocket('wss://ws.kraken.com');
            wsConnections.kraken = ws;
            
            ws.onopen = () => {
                log('kraken', '‚úÖ Connected');
                connectionStatus.kraken = true;
                updateStatusBar();
                COINS.forEach((coin, i) => {
                    setTimeout(() => {
                        if (ws.readyState === WebSocket.OPEN) {
                            const base = coin.replace('USDT', '');
                            const krakenPair = (base === 'BTC' ? 'XBT' : base) + '/USDT';
                            ws.send(JSON.stringify({
                                event: 'subscribe',
                                pair: [krakenPair],
                                subscription: { name: 'ticker' }
                            }));
                        }
                    }, i * 100);
                });
            };
            
            ws.onmessage = (e) => {
                try {
                    const d = JSON.parse(e.data);
                    if (Array.isArray(d) && d.length >= 4 && Array.isArray(d[1])) {
                        const ticker = d[1];
                        const pair = d[3].replace('XBT', 'BTC');
                        const symbol = pair.replace('/', '');
                        if (ticker.length >= 4) {
                            savePrice('kraken', symbol, parseFloat(ticker[0]), parseFloat(ticker[2]));
                        }
                    }
                } catch (err) {}
            };
            
            ws.onerror = ws.onclose = () => {
                connectionStatus.kraken = false;
                updateStatusBar();
                setTimeout(initKraken, CONFIG.RECONNECT_DELAY);
            };
        }

        
        function initGateio() {
            if (wsConnections.gateio?.readyState === WebSocket.OPEN) return;
            
            const ws = new WebSocket('wss://api.gateio.ws/ws/v4/');
            wsConnections.gateio = ws;
            
            ws.onopen = () => {
                log('gateio', '‚úÖ Connected');
                connectionStatus.gateio = true;
                updateStatusBar();
                COINS.forEach((coin, i) => {
                    setTimeout(() => {
                        if (ws.readyState === WebSocket.OPEN) {
                            const symbol = coin.replace('USDT', '_USDT');
                            ws.send(JSON.stringify({
                                time: Math.floor(Date.now() / 1000),
                                channel: 'spot.tickers',
                                event: 'subscribe',
                                payload: [symbol]
                            }));
                        }
                    }, i * 50);
                });
            };
            
            ws.onmessage = (e) => {
                try {
                    const d = JSON.parse(e.data);
                    if (d.event === 'update' && d.result) {
                        const ticker = d.result;
                        const symbol = (ticker.currency_pair || '').replace('_', '');
                        if (symbol && ticker.highest_bid && ticker.lowest_ask) {
                            savePrice('gateio', symbol, parseFloat(ticker.highest_bid), parseFloat(ticker.lowest_ask));
                        }
                    }
                } catch (err) {}
            };
            
            ws.onerror = ws.onclose = () => {
                connectionStatus.gateio = false;
                updateStatusBar();
                setTimeout(initGateio, CONFIG.RECONNECT_DELAY);
            };
        }

        
        function initPoloniex() {
            if (wsConnections.poloniex?.readyState === WebSocket.OPEN) return;
            
            const ws = new WebSocket('wss://api.poloniex.com/markets/ticker');
            wsConnections.poloniex = ws;
            
            ws.onopen = () => {
                log('poloniex', '‚úÖ Connected');
                connectionStatus.poloniex = true;
                updateStatusBar();
            };
            
            ws.onmessage = (e) => {
                try {
                    const d = JSON.parse(e.data);
                    if (Array.isArray(d) && d[0] === 1002) {
                        const tickers = d[2];
                        if (tickers) {
                            Object.keys(tickers).forEach(pair => {
                                const symbol = pair.replace('_', '');
                                const ticker = tickers[pair];
                                if (ticker && ticker.lowestAsk && ticker.highestBid) {
                                    savePrice('poloniex', symbol, parseFloat(ticker.highestBid), parseFloat(ticker.lowestAsk));
                                }
                            });
                        }
                    }
                } catch (err) {}
            };
            
            ws.onerror = ws.onclose = () => {
                connectionStatus.poloniex = false;
                updateStatusBar();
                setTimeout(initPoloniex, CONFIG.RECONNECT_DELAY);
            };
        }

        
        function initBitstamp() {
            if (wsConnections.bitstamp?.readyState === WebSocket.OPEN) return;
            
            const ws = new WebSocket('wss://ws.bitstamp.net');
            wsConnections.bitstamp = ws;
            
            const supportedPairs = COINS.filter(c => ['BTCUSDT', 'ETHUSDT', 'LTCUSDT', 'BCHUSDT', 'XRPUSDT'].includes(c));
            
            ws.onopen = () => {
                log('bitstamp', '‚úÖ Connected');
                connectionStatus.bitstamp = true;
                updateStatusBar();
                supportedPairs.forEach((coin, i) => {
                    setTimeout(() => {
                        if (ws.readyState === WebSocket.OPEN) {
                            const pair = coin.toLowerCase().replace('usdt', 'usd');
                            ws.send(JSON.stringify({
                                event: 'bts:subscribe',
                                data: { channel: `order_book_${pair}` }
                            }));
                        }
                    }, i * 200);
                });
            };
            
            ws.onmessage = (e) => {
                try {
                    const d = JSON.parse(e.data);
                    if (d.event === 'data' && d.channel && d.data) {
                        const pair = d.channel.replace('order_book_', '').replace('usd', 'USDT').toUpperCase();
                        const data = d.data;
                        if (data.bids && data.bids.length > 0 && data.asks && data.asks.length > 0) {
                            savePrice('bitstamp', pair, parseFloat(data.bids[0][0]), parseFloat(data.asks[0][0]));
                        }
                    }
                } catch (err) {}
            };
            
            ws.onerror = ws.onclose = () => {
                connectionStatus.bitstamp = false;
                updateStatusBar();
                setTimeout(initBitstamp, CONFIG.RECONNECT_DELAY);
            };
        }

        
        function initGemini() {
            if (wsConnections.gemini?.readyState === WebSocket.OPEN) return;
            
            const ws = new WebSocket('wss://api.gemini.com/v1/marketdata');
            wsConnections.gemini = ws;
            
            const supportedPairs = COINS.filter(c => ['BTCUSDT', 'ETHUSDT', 'LTCUSDT', 'BCHUSDT'].includes(c));
            
            ws.onopen = () => {
                log('gemini', '‚úÖ Connected');
                connectionStatus.gemini = true;
                updateStatusBar();
                supportedPairs.forEach((coin, i) => {
                    setTimeout(() => {
                        if (ws.readyState === WebSocket.OPEN) {
                            const base = coin.replace('USDT', '');
                            const geminiPair = base.toLowerCase() + 'usd';
                            ws.send(JSON.stringify({
                                type: 'subscribe',
                                subscriptions: [{ name: 'l2', symbols: [geminiPair] }]
                            }));
                        }
                    }, i * 200);
                });
            };
            
            ws.onmessage = (e) => {
                try {
                    const d = JSON.parse(e.data);
                    if (d.type === 'l2_updates' && d.symbol && d.changes) {
                        const symbol = d.symbol.toUpperCase().replace('USD', 'USDT');
                        let bid = 0, ask = 0;
                        d.changes.forEach(change => {
                            if (change[0] === 'buy' && parseFloat(change[1]) > 0) {
                                bid = Math.max(bid, parseFloat(change[1]));
                            } else if (change[0] === 'sell' && parseFloat(change[1]) > 0) {
                                if (ask === 0 || parseFloat(change[1]) < ask) {
                                    ask = parseFloat(change[1]);
                                }
                            }
                        });
                        if (bid > 0 && ask > 0) {
                            savePrice('gemini', symbol, bid, ask);
                        }
                    }
                } catch (err) {}
            };
            
            ws.onerror = ws.onclose = () => {
                connectionStatus.gemini = false;
                updateStatusBar();
                setTimeout(initGemini, CONFIG.RECONNECT_DELAY);
            };
        }

        
        function updateStatusBar() {
            const connected = Object.values(connectionStatus).filter(Boolean).length;
            const total = Object.keys(connectionStatus).length;
            
            let className = 'disconnected';
            let text = `‚ùå –ù–µ—Ç –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–π`;
            
            if (connected === total) {
                className = 'connected';
                text = `‚úÖ –í—Å–µ ${total} –±–∏—Ä–∂ –ø–æ–¥–∫–ª—é—á–µ–Ω—ã`;
            } else if (connected > 0) {
                className = 'connecting';
                text = `‚è≥ –ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ: ${connected}/${total} –±–∏—Ä–∂`;
            }
            
            statusBar.className = `status-bar ${className}`;
            statusBar.textContent = text;
        }

        function scheduleUpdate() {
            const now = Date.now();
            if (now - lastUpdate < CONFIG.UPDATE_THROTTLE) {
                if (updateTimer) clearTimeout(updateTimer);
                updateTimer = setTimeout(() => {
                    lastUpdate = Date.now();
                    render();
                }, CONFIG.UPDATE_THROTTLE);
                return;
            }
            lastUpdate = now;
            if (updateTimer) clearTimeout(updateTimer);
            render();
        }

        function render() {
            const results = [];
            const exchangeIds = Object.keys(FEES);
            
            for (const coin of COINS) {
                const exchangeData = exchangeIds
                    .map(id => ({
                        id,
                        name: EXCHANGE_NAMES[id],
                        fee: FEES[id],
                        data: prices[id][coin]
                    }))
                    .filter(e => e.data?.bid > 0 && e.data?.ask > 0);
                
                if (exchangeData.length < 2) continue;
                
                let best = { profit: -Infinity, scenario: null, buyEx: null, sellEx: null };
                
                for (const buyEx of exchangeData) {
                    for (const sellEx of exchangeData) {
                        if (buyEx.id === sellEx.id) continue;
                        
                        const profit = calculateProfit(
                            buyEx.data.ask, buyEx.fee,
                            sellEx.data.bid, sellEx.fee,
                            CONFIG.TRADE_AMOUNT
                        );
                        
                        if (profit > best.profit) {
                            best = {
                                profit,
                                scenario: {
                                    buyExchange: buyEx.name,
                                    sellExchange: sellEx.name,
                                },
                                buyEx,
                                sellEx
                            };
                        }
                    }
                }
                
                if (best.scenario) {
                    const recs = calculateRecommendations(
                        coin,
                        best.buyEx.data.ask, best.buyEx.fee,
                        best.sellEx.data.bid, best.sellEx.fee
                    );
                    
                    results.push({
                        coin,
                        profit: best.profit,
                        scenario: best.scenario,
                        exchanges: exchangeData,
                        recommendations: recs,
                        buyPrice: best.buyEx.data.ask,
                        sellPrice: best.sellEx.data.bid,
                    });
                }
            }
            
            results.sort((a, b) => b.profit - a.profit);
            const topResults = results.slice(0, CONFIG.TOP_RESULTS);
            
            if (topResults.length === 0) {
                const totalPrices = Object.values(prices).reduce((sum, p) => sum + Object.keys(p).length, 0);
                contentDiv.innerHTML = `
                    <div class="loading">
                        ${totalPrices === 0 
                            ? '‚è≥ –û–∂–∏–¥–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö —Å –±–∏—Ä–∂...' 
                            : '‚ö†Ô∏è –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —Ä–∞—Å—á–µ—Ç–∞'}
                        <br><br>–ü–æ–ª—É—á–µ–Ω–æ —Ü–µ–Ω: ${totalPrices}
                    </div>
                `;
                return;
            }
            
            const positiveCount = topResults.filter(r => r.profit >= 0).length;
            
            let html = `
                <div class="summary">üèÜ –¢–û–ü-${topResults.length} –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç–µ–π | ${positiveCount} —Å –ø—Ä–∏–±—ã–ª—å—é</div>
                <div class="arbitrage-list">
            `;
            
            for (const result of topResults) {
                const isPositive = result.profit >= 0;
                const profitText = isPositive ? `+${formatPrice(result.profit)}` : formatPrice(result.profit);
                const recs = result.recommendations;
                
                let exchangesHtml = '';
                for (const ex of result.exchanges) {
                    exchangesHtml += `
                        <div class="exchange-row">
                            <span class="exchange-name">${ex.name}:</span>
                            <span class="exchange-prices">
                                –ü–æ–∫—É–ø–∫–∞ ${formatPrice(ex.data.ask)} | –ü—Ä–æ–¥–∞–∂–∞ ${formatPrice(ex.data.bid)}
                            </span>
                        </div>
                    `;
                }
                
                let recsHtml = '';
                const showAmounts = [100, 500, 1000, 2500];
                for (const amount of showAmounts) {
                    const rec = recs.recommendations.find(r => r.amount === amount);
                    if (rec) {
                        const isOptimal = amount === recs.optimalAmount;
                        const profitClass = rec.profit >= 0 ? 'positive' : 'negative';
                        const profitSign = rec.profit >= 0 ? '+' : '';
                        const slippageText = rec.slippage > 0.01 ? ` (–ø—Ä–æ—Å–µ–¥–∞–Ω–∏–µ: ${rec.slippage.toFixed(3)}%)` : '';
                        recsHtml += `
                            <div class="rec-item">
                                <span class="rec-amount">${amount} USDT${isOptimal ? '<span class="optimal-badge">‚≠ê –û–ø—Ç–∏–º–∞–ª—å–Ω–æ</span>' : ''}</span>
                                <span class="rec-profit ${profitClass}">${profitSign}${formatPrice(rec.profit)} USDT${slippageText}</span>
                            </div>
                        `;
                    }
                }
                
                const effClass = recs.efficiency >= 0 ? 'positive' : 'negative';
                const effSign = recs.efficiency >= 0 ? '+' : '';
                
                html += `
                    <div class="arbitrage-card ${isPositive ? 'positive' : 'negative'}">
                        <div class="card-header">
                            <span class="coin-symbol">${result.coin.replace('USDT', '/USDT')}</span>
                            <span class="profit-badge ${isPositive ? 'positive' : 'negative'}">${profitText} USDT</span>
                        </div>
                        <div class="exchanges-grid">${exchangesHtml}</div>
                        <div class="scenario">
                            üí° ${result.scenario.buyExchange} ‚Üí ${result.scenario.sellExchange}
                        </div>
                        
                        <div class="recommendation">
                            <div class="recommendation-title">
                                üìä –û–ø—Ç–∏–º–∞–ª—å–Ω–∞—è —Å—É–º–º–∞ –≤—Ö–æ–¥–∞ (—Å —É—á–µ—Ç–æ–º –ª–∏–∫–≤–∏–¥–Ω–æ—Å—Ç–∏)
                            </div>
                            <div class="efficiency">
                                <div class="efficiency-value ${effClass}">${effSign}${recs.efficiency.toFixed(3)}%</div>
                                <div class="efficiency-label">–≠—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—å (ROI)</div>
                            </div>
                            ${recs.isProfitable && recs.optimalAmount > 0 ? `
                                <div style="margin-top: 10px; padding: 10px; background: rgba(76, 175, 80, 0.1); border-radius: 8px;">
                                    <div style="font-size: 14px; font-weight: 600; color: var(--positive-color); margin-bottom: 6px;">
                                        ‚≠ê –†–µ–∫–æ–º–µ–Ω–¥—É–µ–º–∞—è —Å—É–º–º–∞: <strong>${recs.optimalAmount} USDT</strong>
                                    </div>
                                    <div style="font-size: 12px; color: var(--hint-color);">
                                        üí∞ –ü—Ä–∏–±—ã–ª—å: ~${formatPrice(recs.maxProfit || 0)} USDT<br>
                                        üìä –û—Ü–µ–Ω–∫–∞ –ª–∏–∫–≤–∏–¥–Ω–æ—Å—Ç–∏: –¥–æ ${Math.round(recs.liquidity / 1000)}k USDT –±–µ–∑ —Å–∏–ª—å–Ω–æ–≥–æ –ø—Ä–æ—Å–µ–¥–∞–Ω–∏—è
                                    </div>
                                </div>
                            ` : ''}
                            <div class="recommendation-grid" style="margin-top: 10px;">
                                ${recsHtml}
                            </div>
                            ${recs.isProfitable ? `
                                <div style="margin-top: 10px; font-size: 11px; color: var(--hint-color);">
                                    üí° –°—É–º–º—ã —Ä–∞—Å—Å—á–∏—Ç–∞–Ω—ã —Å —É—á–µ—Ç–æ–º –ø—Ä–æ—Å–µ–¥–∞–Ω–∏—è —Ü–µ–Ω—ã –ø—Ä–∏ –ø–æ–∫—É–ø–∫–µ/–ø—Ä–æ–¥–∞–∂–µ
                                </div>
                            ` : `
                                <div style="margin-top: 10px; font-size: 12px; color: var(--negative-color);">
                                    ‚ö†Ô∏è –ê—Ä–±–∏—Ç—Ä–∞–∂ —É–±—ã—Ç–æ—á–Ω—ã–π –ø—Ä–∏ –ª—é–±–æ–π —Å—É–º–º–µ
                                </div>
                            `}
                        </div>
                    </div>
                `;
            }
            
            html += '</div>';
            contentDiv.innerHTML = html;
        }

        
        function initAll() {
            console.log('üöÄ –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∞—Ä–±–∏—Ç—Ä–∞–∂–Ω–æ–≥–æ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è...');
            console.log(`üìä –ú–æ–Ω–µ—Ç: ${COINS.length}, –ë–∏—Ä–∂: ${Object.keys(FEES).length}`);
            
            updateStatusBar();
            
            initBinance();
            initBybit();
            initOkx();
            initKucoin();
            initBitget();
            initHuobi();
            initCoinbase();
            initBitfinex();
            initBingx();
            initKraken();
            initGateio();
            initPoloniex();
            initBitstamp();
            initGemini();
        }

        function closeAll() {
            Object.values(wsConnections).forEach(ws => {
                if (ws) ws.close();
            });
        }

        refreshBtn.onclick = () => {
            console.log('üîÑ –ü–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ...');
            closeAll();
            
            Object.keys(prices).forEach(k => prices[k] = {});
            Object.keys(connectionStatus).forEach(k => connectionStatus[k] = false);
            bitfinexChannels.clear();
            
            contentDiv.innerHTML = '<div class="loading">‚è≥ –ü–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ –±–∏—Ä–∂–∞–º...</div>';
            updateStatusBar();
            
            setTimeout(initAll, 1000);
        };

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initAll);
        } else {
            initAll();
        }
    </script>
</body>
</html>
